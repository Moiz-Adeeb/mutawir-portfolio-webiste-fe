//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
  providedIn: 'root'
})
export class AuthorizationClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Authorization
   * @return Token
   */
  authorization_Exchange(): Observable<FileResponse> {
    let url_ = this.baseUrl + "/connect/token";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuthorization_Exchange(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuthorization_Exchange(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processAuthorization_Exchange(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class AdminDashboardsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get Complete Admin Dashboard Data
   Combines KPIs, Payment Graphs, and Loan Graphs
   Requires: ViewAdminDashboard permission
   * @param startDate (optional)
   * @param endDate (optional)
   */
  adminDashboards_GetAdminDashboard(startDate: string | null | undefined, endDate: string | null | undefined): Observable<GetAdminDashboardResponseModel> {
    let url_ = this.baseUrl + "/api/v1/admin/dashboards?";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminDashboards_GetAdminDashboard(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminDashboards_GetAdminDashboard(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetAdminDashboardResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetAdminDashboardResponseModel>;
    }));
  }

  protected processAdminDashboards_GetAdminDashboard(response: HttpResponseBase): Observable<GetAdminDashboardResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetAdminDashboardResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Admin Dashboard KPIs
   Returns: Total Companies, Active Subscriptions, Payments, Staff, Loan Amount Given
   Requires: ViewAdminDashboard permission
   * @param startDate (optional)
   * @param endDate (optional)
   */
  adminDashboards_GetAdminDashboardKpi(startDate: string | null | undefined, endDate: string | null | undefined): Observable<GetAdminDashboardKpiResponseModel> {
    let url_ = this.baseUrl + "/api/v1/admin/dashboards/kpi?";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminDashboards_GetAdminDashboardKpi(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminDashboards_GetAdminDashboardKpi(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetAdminDashboardKpiResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetAdminDashboardKpiResponseModel>;
    }));
  }

  protected processAdminDashboards_GetAdminDashboardKpi(response: HttpResponseBase): Observable<GetAdminDashboardKpiResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetAdminDashboardKpiResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Admin Dashboard Payment Graphs
   Returns: Daily Payment Counts and Daily Payment Sums
   Requires: ViewAdminDashboard permission
   * @param startDate (optional)
   * @param endDate (optional)
   */
  adminDashboards_GetAdminDashboardPaymentsGraph(startDate: string | null | undefined, endDate: string | null | undefined): Observable<GetAdminDashboardPaymentsGraphResponseModel> {
    let url_ = this.baseUrl + "/api/v1/admin/dashboards/payments-graph?";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminDashboards_GetAdminDashboardPaymentsGraph(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminDashboards_GetAdminDashboardPaymentsGraph(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetAdminDashboardPaymentsGraphResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetAdminDashboardPaymentsGraphResponseModel>;
    }));
  }

  protected processAdminDashboards_GetAdminDashboardPaymentsGraph(response: HttpResponseBase): Observable<GetAdminDashboardPaymentsGraphResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetAdminDashboardPaymentsGraphResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Admin Dashboard Loan Graphs
   Returns: Daily Loan Request Counts, Approved Loan Amounts, Approved Loan Counts
   Requires: ViewAdminDashboard permission
   * @param startDate (optional)
   * @param endDate (optional)
   */
  adminDashboards_GetAdminDashboardLoanGraph(startDate: string | null | undefined, endDate: string | null | undefined): Observable<GetAdminDashboardLoanGraphResponseModel> {
    let url_ = this.baseUrl + "/api/v1/admin/dashboards/loans-graph?";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminDashboards_GetAdminDashboardLoanGraph(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminDashboards_GetAdminDashboardLoanGraph(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetAdminDashboardLoanGraphResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetAdminDashboardLoanGraphResponseModel>;
    }));
  }

  protected processAdminDashboards_GetAdminDashboardLoanGraph(response: HttpResponseBase): Observable<GetAdminDashboardLoanGraphResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetAdminDashboardLoanGraphResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class AdminRoleClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all admin roles with pagination
   * @param isActive (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  adminRole_GetAdminRoles(isActive: boolean | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetAdminRolesResponseModel> {
    let url_ = this.baseUrl + "/api/v1/admin-roles?";
    if (isActive !== undefined && isActive !== null)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminRole_GetAdminRoles(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminRole_GetAdminRoles(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetAdminRolesResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetAdminRolesResponseModel>;
    }));
  }

  protected processAdminRole_GetAdminRoles(response: HttpResponseBase): Observable<GetAdminRolesResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetAdminRolesResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create new admin role
   */
  adminRole_CreateAdminRole(model: CreateAdminRoleRequestModel): Observable<CreateAdminRoleResponseModel> {
    let url_ = this.baseUrl + "/api/v1/admin-roles";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminRole_CreateAdminRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminRole_CreateAdminRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateAdminRoleResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateAdminRoleResponseModel>;
    }));
  }

  protected processAdminRole_CreateAdminRole(response: HttpResponseBase): Observable<CreateAdminRoleResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateAdminRoleResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get admin role by ID
   */
  adminRole_GetAdminRoleById(id: string): Observable<GetAdminRoleByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/admin-roles/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminRole_GetAdminRoleById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminRole_GetAdminRoleById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetAdminRoleByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetAdminRoleByIdResponseModel>;
    }));
  }

  protected processAdminRole_GetAdminRoleById(response: HttpResponseBase): Observable<GetAdminRoleByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetAdminRoleByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update existing admin role
   */
  adminRole_UpdateAdminRole(id: string, model: UpdateAdminRoleRequestModel): Observable<UpdateAdminRoleResponseModel> {
    let url_ = this.baseUrl + "/api/v1/admin-roles/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminRole_UpdateAdminRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminRole_UpdateAdminRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateAdminRoleResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateAdminRoleResponseModel>;
    }));
  }

  protected processAdminRole_UpdateAdminRole(response: HttpResponseBase): Observable<UpdateAdminRoleResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateAdminRoleResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Delete admin role
   */
  adminRole_DeleteAdminRole(id: string): Observable<DeleteAdminRoleResponseModel> {
    let url_ = this.baseUrl + "/api/v1/admin-roles/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminRole_DeleteAdminRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminRole_DeleteAdminRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DeleteAdminRoleResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DeleteAdminRoleResponseModel>;
    }));
  }

  protected processAdminRole_DeleteAdminRole(response: HttpResponseBase): Observable<DeleteAdminRoleResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DeleteAdminRoleResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get admin roles dropdown list
   */
  adminRole_GetAdminRolesDropDown(): Observable<GetAdminRolesDropDownResponseModel> {
    let url_ = this.baseUrl + "/api/v1/admin-roles/dropdown";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminRole_GetAdminRolesDropDown(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminRole_GetAdminRolesDropDown(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetAdminRolesDropDownResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetAdminRolesDropDownResponseModel>;
    }));
  }

  protected processAdminRole_GetAdminRolesDropDown(response: HttpResponseBase): Observable<GetAdminRolesDropDownResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetAdminRolesDropDownResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class AuditLogClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get Audit Logs
   * @param userId (optional)
   * @param feature (optional)
   * @param action (optional)
   * @param lang (optional)
   * @param entityId (optional)
   * @param parentId (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  auditLog_GetAuditLogs(userId: string | null | undefined, feature: AuditLogFeatureType | null | undefined, action: AuditLogType | null | undefined, lang: Lang | null | undefined, entityId: string | null | undefined, parentId: string | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetAuditLogsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/AuditLog?";
    if (userId !== undefined && userId !== null)
      url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
    if (feature !== undefined && feature !== null)
      url_ += "Feature=" + encodeURIComponent("" + feature) + "&";
    if (action !== undefined && action !== null)
      url_ += "Action=" + encodeURIComponent("" + action) + "&";
    if (lang !== undefined && lang !== null)
      url_ += "Lang=" + encodeURIComponent("" + lang) + "&";
    if (entityId !== undefined && entityId !== null)
      url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
    if (parentId !== undefined && parentId !== null)
      url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuditLog_GetAuditLogs(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuditLog_GetAuditLogs(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetAuditLogsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetAuditLogsResponseModel>;
    }));
  }

  protected processAuditLog_GetAuditLogs(response: HttpResponseBase): Observable<GetAuditLogsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetAuditLogsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class CompanyAdminDashboardsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get Complete Company Admin Dashboard Data
   Combines KPIs, Transaction Graphs, and Loan Graphs (Scoped to Company)
   Requires: ViewCompanyAdminDashboard permission OR CompanyAdmin role
   * @param startDate (optional)
   * @param endDate (optional)
   */
  companyAdminDashboards_GetCompanyAdminDashboard(startDate: string | null | undefined, endDate: string | null | undefined): Observable<GetCompanyAdminDashboardResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-admin/dashboards?";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyAdminDashboards_GetCompanyAdminDashboard(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyAdminDashboards_GetCompanyAdminDashboard(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyAdminDashboardResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyAdminDashboardResponseModel>;
    }));
  }

  protected processCompanyAdminDashboards_GetCompanyAdminDashboard(response: HttpResponseBase): Observable<GetCompanyAdminDashboardResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyAdminDashboardResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Company Admin Dashboard KPIs
   Returns: Total Branches, Active Staff, Loan Requests, Approved/Pending/Rejected Loans, Payrolls
   Requires: ViewCompanyAdminDashboard permission OR CompanyAdmin role
   * @param startDate (optional)
   * @param endDate (optional)
   */
  companyAdminDashboards_GetCompanyAdminDashboardKpi(startDate: string | null | undefined, endDate: string | null | undefined): Observable<GetCompanyAdminDashboardKpiResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-admin/dashboards/kpi?";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyAdminDashboards_GetCompanyAdminDashboardKpi(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyAdminDashboards_GetCompanyAdminDashboardKpi(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyAdminDashboardKpiResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyAdminDashboardKpiResponseModel>;
    }));
  }

  protected processCompanyAdminDashboards_GetCompanyAdminDashboardKpi(response: HttpResponseBase): Observable<GetCompanyAdminDashboardKpiResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyAdminDashboardKpiResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Company Admin Dashboard Transaction Graphs
   Returns: Daily Transaction Counts and Daily Transaction Sums
   Requires: ViewCompanyAdminDashboard permission OR CompanyAdmin role
   * @param startDate (optional)
   * @param endDate (optional)
   */
  companyAdminDashboards_GetCompanyAdminDashboardTransactionsGraph(startDate: string | null | undefined, endDate: string | null | undefined): Observable<GetCompanyAdminDashboardPaymentsGraphResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-admin/dashboards/transactions-graph?";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyAdminDashboards_GetCompanyAdminDashboardTransactionsGraph(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyAdminDashboards_GetCompanyAdminDashboardTransactionsGraph(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyAdminDashboardPaymentsGraphResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyAdminDashboardPaymentsGraphResponseModel>;
    }));
  }

  protected processCompanyAdminDashboards_GetCompanyAdminDashboardTransactionsGraph(response: HttpResponseBase): Observable<GetCompanyAdminDashboardPaymentsGraphResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyAdminDashboardPaymentsGraphResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Company Admin Dashboard Loan Graphs
   Returns: Daily Loan Request Counts, Approved/Pending/Rejected Loan Counts, Approved Loan Amounts
   Requires: ViewCompanyAdminDashboard permission OR CompanyAdmin role
   * @param startDate (optional)
   * @param endDate (optional)
   */
  companyAdminDashboards_GetCompanyAdminDashboardLoanGraph(startDate: string | null | undefined, endDate: string | null | undefined): Observable<GetCompanyAdminDashboardLoanGraphResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-admin/dashboards/loans-graph?";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyAdminDashboards_GetCompanyAdminDashboardLoanGraph(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyAdminDashboards_GetCompanyAdminDashboardLoanGraph(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyAdminDashboardLoanGraphResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyAdminDashboardLoanGraphResponseModel>;
    }));
  }

  protected processCompanyAdminDashboards_GetCompanyAdminDashboardLoanGraph(response: HttpResponseBase): Observable<GetCompanyAdminDashboardLoanGraphResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyAdminDashboardLoanGraphResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class CompanyBranchClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all company branches with pagination (tenant-filtered)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  companyBranch_GetCompanyBranches(isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetCompanyBranchesResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-branches?";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyBranch_GetCompanyBranches(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyBranch_GetCompanyBranches(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyBranchesResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyBranchesResponseModel>;
    }));
  }

  protected processCompanyBranch_GetCompanyBranches(response: HttpResponseBase): Observable<GetCompanyBranchesResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyBranchesResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create new company branch
   */
  companyBranch_CreateCompanyBranch(model: CreateCompanyBranchRequestModel): Observable<CreateCompanyBranchResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-branches";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyBranch_CreateCompanyBranch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyBranch_CreateCompanyBranch(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateCompanyBranchResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateCompanyBranchResponseModel>;
    }));
  }

  protected processCompanyBranch_CreateCompanyBranch(response: HttpResponseBase): Observable<CreateCompanyBranchResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateCompanyBranchResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get company branch by ID (tenant-filtered)
   */
  companyBranch_GetCompanyBranchById(id: string): Observable<GetCompanyBranchByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-branches/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyBranch_GetCompanyBranchById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyBranch_GetCompanyBranchById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyBranchByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyBranchByIdResponseModel>;
    }));
  }

  protected processCompanyBranch_GetCompanyBranchById(response: HttpResponseBase): Observable<GetCompanyBranchByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyBranchByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update existing company branch
   */
  companyBranch_UpdateCompanyBranch(id: string, model: UpdateCompanyBranchRequestModel): Observable<UpdateCompanyBranchResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-branches/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyBranch_UpdateCompanyBranch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyBranch_UpdateCompanyBranch(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateCompanyBranchResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateCompanyBranchResponseModel>;
    }));
  }

  protected processCompanyBranch_UpdateCompanyBranch(response: HttpResponseBase): Observable<UpdateCompanyBranchResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateCompanyBranchResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Delete company branch
   */
  companyBranch_DeleteCompanyBranch(id: string): Observable<DeleteCompanyBranchResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-branches/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyBranch_DeleteCompanyBranch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyBranch_DeleteCompanyBranch(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DeleteCompanyBranchResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DeleteCompanyBranchResponseModel>;
    }));
  }

  protected processCompanyBranch_DeleteCompanyBranch(response: HttpResponseBase): Observable<DeleteCompanyBranchResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DeleteCompanyBranchResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get company branches dropdown list (tenant-filtered)
   */
  companyBranch_GetCompanyBranchesDropDown(): Observable<GetCompanyBranchesDropDownResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-branches/dropdown";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyBranch_GetCompanyBranchesDropDown(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyBranch_GetCompanyBranchesDropDown(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyBranchesDropDownResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyBranchesDropDownResponseModel>;
    }));
  }

  protected processCompanyBranch_GetCompanyBranchesDropDown(response: HttpResponseBase): Observable<GetCompanyBranchesDropDownResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyBranchesDropDownResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class CompanyClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Register a new company (Public endpoint - No authentication required)
   */
  company_RegisterCompany(model: RegisterCompanyRequestModel): Observable<RegisterCompanyResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies/register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_RegisterCompany(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_RegisterCompany(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RegisterCompanyResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RegisterCompanyResponseModel>;
    }));
  }

  protected processCompany_RegisterCompany(response: HttpResponseBase): Observable<RegisterCompanyResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RegisterCompanyResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get All Companies (Paginated)
   Requires: Administrator role OR ViewCompanies permission
   * @param status (optional)
   * @param isActive (optional)
   * @param subscriptionActive (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  company_GetCompanies(status: RequestStatus | null | undefined, isActive: boolean | null | undefined, subscriptionActive: boolean | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetCompaniesResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies?";
    if (status !== undefined && status !== null)
      url_ += "Status=" + encodeURIComponent("" + status) + "&";
    if (isActive !== undefined && isActive !== null)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (subscriptionActive !== undefined && subscriptionActive !== null)
      url_ += "SubscriptionActive=" + encodeURIComponent("" + subscriptionActive) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_GetCompanies(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_GetCompanies(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompaniesResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompaniesResponseModel>;
    }));
  }

  protected processCompany_GetCompanies(response: HttpResponseBase): Observable<GetCompaniesResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompaniesResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get current company profile
   */
  company_GetCompanyProfile(): Observable<GetCompanyProfileResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies/profile";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_GetCompanyProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_GetCompanyProfile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyProfileResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyProfileResponseModel>;
    }));
  }

  protected processCompany_GetCompanyProfile(response: HttpResponseBase): Observable<GetCompanyProfileResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyProfileResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update current company profile
   Requires: Authenticated company admin
   */
  company_UpdateCompanyProfile(model: UpdateCompanyProfileRequestModel): Observable<UpdateCompanyProfileResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies/profile";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_UpdateCompanyProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_UpdateCompanyProfile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateCompanyProfileResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateCompanyProfileResponseModel>;
    }));
  }

  protected processCompany_UpdateCompanyProfile(response: HttpResponseBase): Observable<UpdateCompanyProfileResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateCompanyProfileResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Company By Id
   Requires: Administrator role OR ViewCompanies permission
   */
  company_GetCompanyById(id: string): Observable<GetCompanyByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_GetCompanyById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_GetCompanyById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyByIdResponseModel>;
    }));
  }

  protected processCompany_GetCompanyById(response: HttpResponseBase): Observable<GetCompanyByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Company Detail By Id
   Requires: Administrator role OR ViewCompanies permission
   */
  company_GetCompanyDetailById(id: string): Observable<GetCompanyDetailByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies/{id}/detail";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_GetCompanyDetailById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_GetCompanyDetailById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyDetailByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyDetailByIdResponseModel>;
    }));
  }

  protected processCompany_GetCompanyDetailById(response: HttpResponseBase): Observable<GetCompanyDetailByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyDetailByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Approve Company Registration
   Requires: Administrator role OR ApproveCompanies permission
   */
  company_ApproveCompany(id: string, model: ApproveCompanyRequestModel): Observable<ApproveCompanyResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies/{id}/approve";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_ApproveCompany(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_ApproveCompany(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ApproveCompanyResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ApproveCompanyResponseModel>;
    }));
  }

  protected processCompany_ApproveCompany(response: HttpResponseBase): Observable<ApproveCompanyResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ApproveCompanyResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Reject Company Registration
   Requires: Administrator role OR RejectCompanies permission
   */
  company_RejectCompany(id: string, model: RejectCompanyRequestModel): Observable<RejectCompanyResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies/{id}/reject";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_RejectCompany(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_RejectCompany(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RejectCompanyResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RejectCompanyResponseModel>;
    }));
  }

  protected processCompany_RejectCompany(response: HttpResponseBase): Observable<RejectCompanyResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RejectCompanyResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Assign Subscription to Company
   Requires: Administrator role OR AssignSubscriptionPlan permission
   */
  company_AssignSubscription(id: string, model: AssignSubscriptionRequestModel): Observable<AssignSubscriptionResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies/{id}/assign-subscription";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_AssignSubscription(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_AssignSubscription(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<AssignSubscriptionResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<AssignSubscriptionResponseModel>;
    }));
  }

  protected processCompany_AssignSubscription(response: HttpResponseBase): Observable<AssignSubscriptionResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AssignSubscriptionResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Check if current user is active and their company is active
   Requires: Any authenticated user
   */
  company_CheckUserActiveStatus(): Observable<CheckUserActiveStatusResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies/check-active-status";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_CheckUserActiveStatus(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_CheckUserActiveStatus(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CheckUserActiveStatusResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CheckUserActiveStatusResponseModel>;
    }));
  }

  protected processCompany_CheckUserActiveStatus(response: HttpResponseBase): Observable<CheckUserActiveStatusResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CheckUserActiveStatusResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Check if current user has an active subscription
   Requires: Any authenticated user
   */
  company_CheckUserSubscription(): Observable<CheckUserSubscriptionResponseModel> {
    let url_ = this.baseUrl + "/api/v1/companies/check-subscription";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompany_CheckUserSubscription(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompany_CheckUserSubscription(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CheckUserSubscriptionResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CheckUserSubscriptionResponseModel>;
    }));
  }

  protected processCompany_CheckUserSubscription(response: HttpResponseBase): Observable<CheckUserSubscriptionResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CheckUserSubscriptionResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class CompanyRoleClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all company roles with pagination (tenant-filtered)
   * @param search (optional)
   * @param isActive (optional)
   * @param isHideCount (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  companyRole_GetCompanyRoles(search: string | null | undefined, isActive: boolean | null | undefined, isHideCount: boolean | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetCompanyRolesResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-roles?";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isActive !== undefined && isActive !== null)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyRole_GetCompanyRoles(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyRole_GetCompanyRoles(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyRolesResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyRolesResponseModel>;
    }));
  }

  protected processCompanyRole_GetCompanyRoles(response: HttpResponseBase): Observable<GetCompanyRolesResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyRolesResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create new company role
   */
  companyRole_CreateCompanyRole(model: CreateCompanyRoleRequestModel): Observable<CreateCompanyRoleResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-roles";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyRole_CreateCompanyRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyRole_CreateCompanyRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateCompanyRoleResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateCompanyRoleResponseModel>;
    }));
  }

  protected processCompanyRole_CreateCompanyRole(response: HttpResponseBase): Observable<CreateCompanyRoleResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateCompanyRoleResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get company role by ID (tenant-filtered)
   */
  companyRole_GetCompanyRoleById(id: string): Observable<GetCompanyRoleByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-roles/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyRole_GetCompanyRoleById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyRole_GetCompanyRoleById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyRoleByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyRoleByIdResponseModel>;
    }));
  }

  protected processCompanyRole_GetCompanyRoleById(response: HttpResponseBase): Observable<GetCompanyRoleByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyRoleByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update existing company role
   */
  companyRole_UpdateCompanyRole(id: string, model: UpdateCompanyRoleRequestModel): Observable<UpdateCompanyRoleResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-roles/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyRole_UpdateCompanyRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyRole_UpdateCompanyRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateCompanyRoleResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateCompanyRoleResponseModel>;
    }));
  }

  protected processCompanyRole_UpdateCompanyRole(response: HttpResponseBase): Observable<UpdateCompanyRoleResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateCompanyRoleResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Delete company role
   */
  companyRole_DeleteCompanyRole(id: string): Observable<DeleteCompanyRoleResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-roles/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyRole_DeleteCompanyRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyRole_DeleteCompanyRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DeleteCompanyRoleResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DeleteCompanyRoleResponseModel>;
    }));
  }

  protected processCompanyRole_DeleteCompanyRole(response: HttpResponseBase): Observable<DeleteCompanyRoleResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DeleteCompanyRoleResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get company roles dropdown list (tenant-filtered)
   */
  companyRole_GetCompanyRolesDropDown(): Observable<GetCompanyRolesDropDownResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-roles/dropdown";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyRole_GetCompanyRolesDropDown(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyRole_GetCompanyRolesDropDown(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyRolesDropDownResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyRolesDropDownResponseModel>;
    }));
  }

  protected processCompanyRole_GetCompanyRolesDropDown(response: HttpResponseBase): Observable<GetCompanyRolesDropDownResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyRolesDropDownResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class CompanySettingClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get company settings (optionally filtered by key)
   Requires: ViewCompanySettings permission OR CompanyAdmin role
   * @param keys (optional)
   */
  companySetting_GetCompanySettings(keys: string[] | null | undefined): Observable<GetCompanySettingsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-settings?";
    if (keys !== undefined && keys !== null)
      keys && keys.forEach(item => { url_ += "Keys=" + encodeURIComponent("" + item) + "&"; });
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanySetting_GetCompanySettings(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanySetting_GetCompanySettings(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanySettingsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanySettingsResponseModel>;
    }));
  }

  protected processCompanySetting_GetCompanySettings(response: HttpResponseBase): Observable<GetCompanySettingsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanySettingsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update company settings
   Requires: UpdateCompanySettings permission OR CompanyAdmin role
   * @param model Dictionary of setting key-value pairs to update
   */
  companySetting_UpdateCompanySettings(model: UpdateCompanySettingsRequestModel): Observable<UpdateCompanySettingsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-settings";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanySetting_UpdateCompanySettings(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanySetting_UpdateCompanySettings(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateCompanySettingsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateCompanySettingsResponseModel>;
    }));
  }

  protected processCompanySetting_UpdateCompanySettings(response: HttpResponseBase): Observable<UpdateCompanySettingsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateCompanySettingsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get public company settings (accessible by employees)
   Returns only InterestRate and EarlyRepaymentAllowed
   Requires: Employee role
   */
  companySetting_GetCompanySettingsPublic(): Observable<GetCompanySettingsPublicResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-settings/public";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanySetting_GetCompanySettingsPublic(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanySetting_GetCompanySettingsPublic(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanySettingsPublicResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanySettingsPublicResponseModel>;
    }));
  }

  protected processCompanySetting_GetCompanySettingsPublic(response: HttpResponseBase): Observable<GetCompanySettingsPublicResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanySettingsPublicResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class CompanyStaffClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all company staff with pagination (tenant-filtered)
   * @param isEnabled (optional)
   * @param companyRoleId (optional)
   * @param branchId (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  companyStaff_GetCompanyStaffs(isEnabled: boolean | null | undefined, companyRoleId: string | null | undefined, branchId: string | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetCompanyStaffsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-staff?";
    if (isEnabled !== undefined && isEnabled !== null)
      url_ += "IsEnabled=" + encodeURIComponent("" + isEnabled) + "&";
    if (companyRoleId !== undefined && companyRoleId !== null)
      url_ += "CompanyRoleId=" + encodeURIComponent("" + companyRoleId) + "&";
    if (branchId !== undefined && branchId !== null)
      url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyStaff_GetCompanyStaffs(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyStaff_GetCompanyStaffs(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyStaffsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyStaffsResponseModel>;
    }));
  }

  protected processCompanyStaff_GetCompanyStaffs(response: HttpResponseBase): Observable<GetCompanyStaffsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyStaffsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create new company staff
   */
  companyStaff_CreateCompanyStaff(model: CreateCompanyStaffRequestModel): Observable<CreateCompanyStaffResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-staff";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyStaff_CreateCompanyStaff(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyStaff_CreateCompanyStaff(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateCompanyStaffResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateCompanyStaffResponseModel>;
    }));
  }

  protected processCompanyStaff_CreateCompanyStaff(response: HttpResponseBase): Observable<CreateCompanyStaffResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateCompanyStaffResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get all company staff for payroll with pagination (tenant-filtered)
   * @param month (optional)
   * @param year (optional)
   * @param branchId (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  companyStaff_GetCompanyStaffsForPayRoll(month: number | undefined, year: number | undefined, branchId: string | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetCompanyStaffsForPayRollResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-staff/payroll?";
    if (month === null)
      throw new globalThis.Error("The parameter 'month' cannot be null.");
    else if (month !== undefined)
      url_ += "Month=" + encodeURIComponent("" + month) + "&";
    if (year === null)
      throw new globalThis.Error("The parameter 'year' cannot be null.");
    else if (year !== undefined)
      url_ += "Year=" + encodeURIComponent("" + year) + "&";
    if (branchId !== undefined && branchId !== null)
      url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyStaff_GetCompanyStaffsForPayRoll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyStaff_GetCompanyStaffsForPayRoll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyStaffsForPayRollResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyStaffsForPayRollResponseModel>;
    }));
  }

  protected processCompanyStaff_GetCompanyStaffsForPayRoll(response: HttpResponseBase): Observable<GetCompanyStaffsForPayRollResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyStaffsForPayRollResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get company staff by ID (tenant-filtered)
   */
  companyStaff_GetCompanyStaffById(id: string): Observable<GetCompanyStaffByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-staff/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyStaff_GetCompanyStaffById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyStaff_GetCompanyStaffById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyStaffByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyStaffByIdResponseModel>;
    }));
  }

  protected processCompanyStaff_GetCompanyStaffById(response: HttpResponseBase): Observable<GetCompanyStaffByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyStaffByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update existing company staff
   */
  companyStaff_UpdateCompanyStaff(id: string, model: UpdateCompanyStaffRequestModel): Observable<UpdateCompanyStaffResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-staff/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyStaff_UpdateCompanyStaff(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyStaff_UpdateCompanyStaff(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateCompanyStaffResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateCompanyStaffResponseModel>;
    }));
  }

  protected processCompanyStaff_UpdateCompanyStaff(response: HttpResponseBase): Observable<UpdateCompanyStaffResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateCompanyStaffResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Delete company staff
   */
  companyStaff_DeleteCompanyStaff(id: string): Observable<DeleteCompanyStaffResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-staff/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyStaff_DeleteCompanyStaff(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyStaff_DeleteCompanyStaff(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DeleteCompanyStaffResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DeleteCompanyStaffResponseModel>;
    }));
  }

  protected processCompanyStaff_DeleteCompanyStaff(response: HttpResponseBase): Observable<DeleteCompanyStaffResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DeleteCompanyStaffResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get company staff dropdown list (tenant-filtered)
   */
  companyStaff_GetCompanyStaffsDropDown(): Observable<GetCompanyStaffsDropDownResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-staff/dropdown";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyStaff_GetCompanyStaffsDropDown(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyStaff_GetCompanyStaffsDropDown(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyStaffsDropDownResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyStaffsDropDownResponseModel>;
    }));
  }

  protected processCompanyStaff_GetCompanyStaffsDropDown(response: HttpResponseBase): Observable<GetCompanyStaffsDropDownResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyStaffsDropDownResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update current company staff profile
   Requires: Authenticated company staff
   */
  companyStaff_UpdateCompanyStaffProfile(model: UpdateCompanyStaffProfileRequestModel): Observable<UpdateCompanyStaffProfileResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-staff/profile";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyStaff_UpdateCompanyStaffProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyStaff_UpdateCompanyStaffProfile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateCompanyStaffProfileResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateCompanyStaffProfileResponseModel>;
    }));
  }

  protected processCompanyStaff_UpdateCompanyStaffProfile(response: HttpResponseBase): Observable<UpdateCompanyStaffProfileResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateCompanyStaffProfileResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Company Staff Profile
   */
  companyStaff_GetCompanyStaffProfile(): Observable<GetCompanyStaffProfileResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-staff/profile";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanyStaff_GetCompanyStaffProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyStaff_GetCompanyStaffProfile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanyStaffProfileResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanyStaffProfileResponseModel>;
    }));
  }

  protected processCompanyStaff_GetCompanyStaffProfile(response: HttpResponseBase): Observable<GetCompanyStaffProfileResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanyStaffProfileResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class CompanySubscriptionRequestClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Create a new subscription request (Company Admin only)
   */
  companySubscriptionRequest_CreateSubscriptionRequest(model: CreateCompanySubscriptionRequestModel): Observable<CreateCompanySubscriptionRequestResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-subscription-requests";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanySubscriptionRequest_CreateSubscriptionRequest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanySubscriptionRequest_CreateSubscriptionRequest(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateCompanySubscriptionRequestResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateCompanySubscriptionRequestResponseModel>;
    }));
  }

  protected processCompanySubscriptionRequest_CreateSubscriptionRequest(response: HttpResponseBase): Observable<CreateCompanySubscriptionRequestResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateCompanySubscriptionRequestResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get all subscription requests (Paginated)
   Requires: Administrator role OR ViewCompanySubscriptionRequests permission
   * @param status (optional)
   * @param companyId (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  companySubscriptionRequest_GetSubscriptionRequests(status: RequestStatus | null | undefined, companyId: string | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetCompanySubscriptionRequestsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-subscription-requests?";
    if (status !== undefined && status !== null)
      url_ += "Status=" + encodeURIComponent("" + status) + "&";
    if (companyId !== undefined && companyId !== null)
      url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanySubscriptionRequest_GetSubscriptionRequests(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanySubscriptionRequest_GetSubscriptionRequests(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanySubscriptionRequestsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanySubscriptionRequestsResponseModel>;
    }));
  }

  protected processCompanySubscriptionRequest_GetSubscriptionRequests(response: HttpResponseBase): Observable<GetCompanySubscriptionRequestsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanySubscriptionRequestsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get subscription request by ID
   Requires: Administrator role OR ViewCompanySubscriptionRequests permission
   */
  companySubscriptionRequest_GetSubscriptionRequestById(id: string): Observable<GetCompanySubscriptionRequestByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-subscription-requests/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanySubscriptionRequest_GetSubscriptionRequestById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanySubscriptionRequest_GetSubscriptionRequestById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetCompanySubscriptionRequestByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetCompanySubscriptionRequestByIdResponseModel>;
    }));
  }

  protected processCompanySubscriptionRequest_GetSubscriptionRequestById(response: HttpResponseBase): Observable<GetCompanySubscriptionRequestByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetCompanySubscriptionRequestByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Approve subscription request (Admin only)
   Requires: Administrator role OR ApproveCompanySubscriptionRequests permission
   */
  companySubscriptionRequest_ApproveSubscriptionRequest(id: string, model: ApproveCompanySubscriptionRequestModel): Observable<ApproveCompanySubscriptionRequestResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-subscription-requests/{id}/approve";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanySubscriptionRequest_ApproveSubscriptionRequest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanySubscriptionRequest_ApproveSubscriptionRequest(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ApproveCompanySubscriptionRequestResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ApproveCompanySubscriptionRequestResponseModel>;
    }));
  }

  protected processCompanySubscriptionRequest_ApproveSubscriptionRequest(response: HttpResponseBase): Observable<ApproveCompanySubscriptionRequestResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ApproveCompanySubscriptionRequestResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Reject subscription request (Admin only)
   Requires: Administrator role OR RejectCompanySubscriptionRequests permission
   */
  companySubscriptionRequest_RejectSubscriptionRequest(id: string, model: RejectCompanySubscriptionRequestModel): Observable<RejectCompanySubscriptionRequestResponseModel> {
    let url_ = this.baseUrl + "/api/v1/company-subscription-requests/{id}/reject";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCompanySubscriptionRequest_RejectSubscriptionRequest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanySubscriptionRequest_RejectSubscriptionRequest(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RejectCompanySubscriptionRequestResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RejectCompanySubscriptionRequestResponseModel>;
    }));
  }

  protected processCompanySubscriptionRequest_RejectSubscriptionRequest(response: HttpResponseBase): Observable<RejectCompanySubscriptionRequestResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RejectCompanySubscriptionRequestResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class DashboardClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get current employee dashboard
   */
  dashboard_GetEmployeeDashboard(): Observable<GetEmployeeDashboardResponseModel> {
    let url_ = this.baseUrl + "/api/v1/Dashboard";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDashboard_GetEmployeeDashboard(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDashboard_GetEmployeeDashboard(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetEmployeeDashboardResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetEmployeeDashboardResponseModel>;
    }));
  }

  protected processDashboard_GetEmployeeDashboard(response: HttpResponseBase): Observable<GetEmployeeDashboardResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetEmployeeDashboardResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class LoanOfferClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all loan offers with pagination (tenant-filtered)
   * @param isActive (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  loanOffer_GetLoanOffers(isActive: boolean | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetLoanOffersResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-offers?";
    if (isActive !== undefined && isActive !== null)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanOffer_GetLoanOffers(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanOffer_GetLoanOffers(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetLoanOffersResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetLoanOffersResponseModel>;
    }));
  }

  protected processLoanOffer_GetLoanOffers(response: HttpResponseBase): Observable<GetLoanOffersResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetLoanOffersResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create new loan offer
   */
  loanOffer_CreateLoanOffer(model: CreateLoanOfferRequestModel): Observable<CreateLoanOfferResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-offers";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanOffer_CreateLoanOffer(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanOffer_CreateLoanOffer(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateLoanOfferResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateLoanOfferResponseModel>;
    }));
  }

  protected processLoanOffer_CreateLoanOffer(response: HttpResponseBase): Observable<CreateLoanOfferResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateLoanOfferResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get all active loan offers with pagination (tenant-filtered)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  loanOffer_GetLoanOffersPublic(isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetLoanOffersPublicResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-offers/employee?";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanOffer_GetLoanOffersPublic(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanOffer_GetLoanOffersPublic(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetLoanOffersPublicResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetLoanOffersPublicResponseModel>;
    }));
  }

  protected processLoanOffer_GetLoanOffersPublic(response: HttpResponseBase): Observable<GetLoanOffersPublicResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetLoanOffersPublicResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get loan offer by ID (tenant-filtered)
   */
  loanOffer_GetLoanOfferById(id: string): Observable<GetLoanOfferByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-offers/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanOffer_GetLoanOfferById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanOffer_GetLoanOfferById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetLoanOfferByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetLoanOfferByIdResponseModel>;
    }));
  }

  protected processLoanOffer_GetLoanOfferById(response: HttpResponseBase): Observable<GetLoanOfferByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetLoanOfferByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update existing loan offer
   */
  loanOffer_UpdateLoanOffer(id: string, model: UpdateLoanOfferRequestModel): Observable<UpdateLoanOfferResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-offers/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanOffer_UpdateLoanOffer(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanOffer_UpdateLoanOffer(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateLoanOfferResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateLoanOfferResponseModel>;
    }));
  }

  protected processLoanOffer_UpdateLoanOffer(response: HttpResponseBase): Observable<UpdateLoanOfferResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateLoanOfferResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Delete loan offer
   */
  loanOffer_DeleteLoanOffer(id: string): Observable<DeleteLoanOfferResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-offers/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanOffer_DeleteLoanOffer(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanOffer_DeleteLoanOffer(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DeleteLoanOfferResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DeleteLoanOfferResponseModel>;
    }));
  }

  protected processLoanOffer_DeleteLoanOffer(response: HttpResponseBase): Observable<DeleteLoanOfferResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DeleteLoanOfferResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get active loan offers dropdown list (tenant-filtered)
   */
  loanOffer_GetLoanOffersDropDown(): Observable<GetLoanOffersDropDownResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-offers/dropdown";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanOffer_GetLoanOffersDropDown(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanOffer_GetLoanOffersDropDown(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetLoanOffersDropDownResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetLoanOffersDropDownResponseModel>;
    }));
  }

  protected processLoanOffer_GetLoanOffersDropDown(response: HttpResponseBase): Observable<GetLoanOffersDropDownResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetLoanOffersDropDownResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class LoanPaymentClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Pay back a loan payment schedule
   */
  loanPayment_PayBack(model: PayBackLoanRequestModel): Observable<PayBackLoanResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-payment/payback";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanPayment_PayBack(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanPayment_PayBack(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PayBackLoanResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PayBackLoanResponseModel>;
    }));
  }

  protected processLoanPayment_PayBack(response: HttpResponseBase): Observable<PayBackLoanResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PayBackLoanResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class LoanPaymentScheduleClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all loan payment schedules with pagination and filters (tenant-filtered)
   * @param loanRequestId (optional)
   * @param month (optional)
   * @param year (optional)
   * @param isPayed (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  loanPaymentSchedule_GetLoanPaymentSchedulesEmployee(loanRequestId: string | null | undefined, month: number | null | undefined, year: number | null | undefined, isPayed: boolean | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetLoanPaymentSchedulesEmployeeResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-payment-schedules/employee?";
    if (loanRequestId !== undefined && loanRequestId !== null)
      url_ += "LoanRequestId=" + encodeURIComponent("" + loanRequestId) + "&";
    if (month !== undefined && month !== null)
      url_ += "Month=" + encodeURIComponent("" + month) + "&";
    if (year !== undefined && year !== null)
      url_ += "Year=" + encodeURIComponent("" + year) + "&";
    if (isPayed !== undefined && isPayed !== null)
      url_ += "IsPayed=" + encodeURIComponent("" + isPayed) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanPaymentSchedule_GetLoanPaymentSchedulesEmployee(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanPaymentSchedule_GetLoanPaymentSchedulesEmployee(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetLoanPaymentSchedulesEmployeeResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetLoanPaymentSchedulesEmployeeResponseModel>;
    }));
  }

  protected processLoanPaymentSchedule_GetLoanPaymentSchedulesEmployee(response: HttpResponseBase): Observable<GetLoanPaymentSchedulesEmployeeResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetLoanPaymentSchedulesEmployeeResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get all loan payment schedules with pagination and filters (tenant-filtered)
   * @param loanRequestId (optional)
   * @param companyStaffId (optional)
   * @param month (optional)
   * @param year (optional)
   * @param isPayed (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  loanPaymentSchedule_GetLoanPaymentSchedules(loanRequestId: string | null | undefined, companyStaffId: string | null | undefined, month: number | null | undefined, year: number | null | undefined, isPayed: boolean | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetLoanPaymentSchedulesResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-payment-schedules?";
    if (loanRequestId !== undefined && loanRequestId !== null)
      url_ += "LoanRequestId=" + encodeURIComponent("" + loanRequestId) + "&";
    if (companyStaffId !== undefined && companyStaffId !== null)
      url_ += "CompanyStaffId=" + encodeURIComponent("" + companyStaffId) + "&";
    if (month !== undefined && month !== null)
      url_ += "Month=" + encodeURIComponent("" + month) + "&";
    if (year !== undefined && year !== null)
      url_ += "Year=" + encodeURIComponent("" + year) + "&";
    if (isPayed !== undefined && isPayed !== null)
      url_ += "IsPayed=" + encodeURIComponent("" + isPayed) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanPaymentSchedule_GetLoanPaymentSchedules(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanPaymentSchedule_GetLoanPaymentSchedules(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetLoanPaymentSchedulesResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetLoanPaymentSchedulesResponseModel>;
    }));
  }

  protected processLoanPaymentSchedule_GetLoanPaymentSchedules(response: HttpResponseBase): Observable<GetLoanPaymentSchedulesResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetLoanPaymentSchedulesResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get loan payment schedule by ID (tenant-filtered)
   */
  loanPaymentSchedule_GetLoanPaymentScheduleById(id: string): Observable<GetLoanPaymentScheduleByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-payment-schedules/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanPaymentSchedule_GetLoanPaymentScheduleById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanPaymentSchedule_GetLoanPaymentScheduleById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetLoanPaymentScheduleByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetLoanPaymentScheduleByIdResponseModel>;
    }));
  }

  protected processLoanPaymentSchedule_GetLoanPaymentScheduleById(response: HttpResponseBase): Observable<GetLoanPaymentScheduleByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetLoanPaymentScheduleByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class LoanRequestClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all current employees loan requests with pagination (tenant-filtered)
   * @param status (optional)
   * @param type (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  loanRequest_GetEmployeeLoanRequests(status: LoanRequestStatus | null | undefined, type: LoanRequestType | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetEmployeeLoanRequestsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-requests/employee?";
    if (status !== undefined && status !== null)
      url_ += "Status=" + encodeURIComponent("" + status) + "&";
    if (type !== undefined && type !== null)
      url_ += "Type=" + encodeURIComponent("" + type) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanRequest_GetEmployeeLoanRequests(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanRequest_GetEmployeeLoanRequests(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetEmployeeLoanRequestsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetEmployeeLoanRequestsResponseModel>;
    }));
  }

  protected processLoanRequest_GetEmployeeLoanRequests(response: HttpResponseBase): Observable<GetEmployeeLoanRequestsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetEmployeeLoanRequestsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get all loan requests with pagination (tenant-filtered)
   * @param status (optional)
   * @param companyStaffId (optional)
   * @param type (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  loanRequest_GetLoanRequests(status: LoanRequestStatus | null | undefined, companyStaffId: string | null | undefined, type: LoanRequestType | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetLoanRequestsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-requests?";
    if (status !== undefined && status !== null)
      url_ += "Status=" + encodeURIComponent("" + status) + "&";
    if (companyStaffId !== undefined && companyStaffId !== null)
      url_ += "CompanyStaffId=" + encodeURIComponent("" + companyStaffId) + "&";
    if (type !== undefined && type !== null)
      url_ += "Type=" + encodeURIComponent("" + type) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanRequest_GetLoanRequests(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanRequest_GetLoanRequests(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetLoanRequestsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetLoanRequestsResponseModel>;
    }));
  }

  protected processLoanRequest_GetLoanRequests(response: HttpResponseBase): Observable<GetLoanRequestsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetLoanRequestsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create new loan request
   */
  loanRequest_CreateLoanRequest(model: CreateLoanRequestRequestModel): Observable<CreateLoanRequestResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-requests";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanRequest_CreateLoanRequest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanRequest_CreateLoanRequest(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateLoanRequestResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateLoanRequestResponseModel>;
    }));
  }

  protected processLoanRequest_CreateLoanRequest(response: HttpResponseBase): Observable<CreateLoanRequestResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateLoanRequestResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get loan request by ID (tenant-filtered)
   */
  loanRequest_GetLoanRequestById(id: string): Observable<GetLoanRequestByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-requests/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanRequest_GetLoanRequestById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanRequest_GetLoanRequestById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetLoanRequestByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetLoanRequestByIdResponseModel>;
    }));
  }

  protected processLoanRequest_GetLoanRequestById(response: HttpResponseBase): Observable<GetLoanRequestByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetLoanRequestByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Approve loan request
   */
  loanRequest_ApproveLoanRequest(id: string): Observable<ApproveLoanRequestResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-requests/{id}/approve";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanRequest_ApproveLoanRequest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanRequest_ApproveLoanRequest(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ApproveLoanRequestResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ApproveLoanRequestResponseModel>;
    }));
  }

  protected processLoanRequest_ApproveLoanRequest(response: HttpResponseBase): Observable<ApproveLoanRequestResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ApproveLoanRequestResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Reject loan request
   */
  loanRequest_RejectLoanRequest(id: string, model: RejectLoanRequestRequestModel): Observable<RejectLoanRequestResponseModel> {
    let url_ = this.baseUrl + "/api/v1/loan-requests/{id}/reject";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLoanRequest_RejectLoanRequest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoanRequest_RejectLoanRequest(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RejectLoanRequestResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RejectLoanRequestResponseModel>;
    }));
  }

  protected processLoanRequest_RejectLoanRequest(response: HttpResponseBase): Observable<RejectLoanRequestResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RejectLoanRequestResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class NotificationClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get Notifications
   * @param isRead (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  notification_GetNotifications(isRead: boolean | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetNotificationsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/Notification?";
    if (isRead !== undefined && isRead !== null)
      url_ += "IsRead=" + encodeURIComponent("" + isRead) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotification_GetNotifications(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotification_GetNotifications(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetNotificationsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetNotificationsResponseModel>;
    }));
  }

  protected processNotification_GetNotifications(response: HttpResponseBase): Observable<GetNotificationsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetNotificationsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Unread Notification Count
   */
  notification_GetUnReadNotificationCount(): Observable<GetUnReadNotificationCountResponseModel> {
    let url_ = this.baseUrl + "/api/v1/Notification/count";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotification_GetUnReadNotificationCount(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotification_GetUnReadNotificationCount(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetUnReadNotificationCountResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetUnReadNotificationCountResponseModel>;
    }));
  }

  protected processNotification_GetUnReadNotificationCount(response: HttpResponseBase): Observable<GetUnReadNotificationCountResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetUnReadNotificationCountResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Read Notification
   */
  notification_ReadNotification(id: string): Observable<ReadNotificationResponseModel> {
    let url_ = this.baseUrl + "/api/v1/Notification/read/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotification_ReadNotification(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotification_ReadNotification(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ReadNotificationResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ReadNotificationResponseModel>;
    }));
  }

  protected processNotification_ReadNotification(response: HttpResponseBase): Observable<ReadNotificationResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ReadNotificationResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Read All Notification
   */
  notification_ReadAllUnReadNotification(): Observable<ReadAllUnReadNotificationResponseModel> {
    let url_ = this.baseUrl + "/api/v1/Notification/readAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotification_ReadAllUnReadNotification(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotification_ReadAllUnReadNotification(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ReadAllUnReadNotificationResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ReadAllUnReadNotificationResponseModel>;
    }));
  }

  protected processNotification_ReadAllUnReadNotification(response: HttpResponseBase): Observable<ReadAllUnReadNotificationResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ReadAllUnReadNotificationResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class NotificationDeviceClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Create or Update Notification Device
   */
  notificationDevice_CreateNotificationDevice(model: CreateNotificationDeviceRequestModel): Observable<CreateNotificationDeviceResponseModel> {
    let url_ = this.baseUrl + "/api/v1/NotificationDevice";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotificationDevice_CreateNotificationDevice(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotificationDevice_CreateNotificationDevice(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateNotificationDeviceResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateNotificationDeviceResponseModel>;
    }));
  }

  protected processNotificationDevice_CreateNotificationDevice(response: HttpResponseBase): Observable<CreateNotificationDeviceResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateNotificationDeviceResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class PaymentClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all payments (Paginated)
   Requires: Administrator role OR ViewPayments permission
   * @param companyId (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  payment_GetPayments(companyId: string | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetPaymentsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/payments?";
    if (companyId !== undefined && companyId !== null)
      url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPayment_GetPayments(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPayment_GetPayments(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetPaymentsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetPaymentsResponseModel>;
    }));
  }

  protected processPayment_GetPayments(response: HttpResponseBase): Observable<GetPaymentsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetPaymentsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get payment by ID
   Requires: Administrator role OR ViewPayments permission
   */
  payment_GetPaymentById(id: string): Observable<GetPaymentByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/payments/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPayment_GetPaymentById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPayment_GetPaymentById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetPaymentByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetPaymentByIdResponseModel>;
    }));
  }

  protected processPayment_GetPaymentById(response: HttpResponseBase): Observable<GetPaymentByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetPaymentByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class PayrollClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all payrolls with pagination and filtering (tenant-filtered)
   * @param month (optional)
   * @param year (optional)
   * @param branchId (optional)
   * @param companyStaffId (optional)
   * @param search (optional)
   * @param isHideCount (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  payroll_GetPayrolls(month: number | null | undefined, year: number | null | undefined, branchId: string | null | undefined, companyStaffId: string | null | undefined, search: string | null | undefined, isHideCount: boolean | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetPayrollsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/payroll?";
    if (month !== undefined && month !== null)
      url_ += "Month=" + encodeURIComponent("" + month) + "&";
    if (year !== undefined && year !== null)
      url_ += "Year=" + encodeURIComponent("" + year) + "&";
    if (branchId !== undefined && branchId !== null)
      url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
    if (companyStaffId !== undefined && companyStaffId !== null)
      url_ += "CompanyStaffId=" + encodeURIComponent("" + companyStaffId) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPayroll_GetPayrolls(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPayroll_GetPayrolls(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetPayrollsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetPayrollsResponseModel>;
    }));
  }

  protected processPayroll_GetPayrolls(response: HttpResponseBase): Observable<GetPayrollsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetPayrollsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create payroll for selected staff members for a specific month/year
   */
  payroll_CreatePayroll(model: CreatePayrollRequestModel): Observable<CreatePayrollResponseModel> {
    let url_ = this.baseUrl + "/api/v1/payroll";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPayroll_CreatePayroll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPayroll_CreatePayroll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreatePayrollResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreatePayrollResponseModel>;
    }));
  }

  protected processPayroll_CreatePayroll(response: HttpResponseBase): Observable<CreatePayrollResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreatePayrollResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get payroll by ID (tenant-filtered)
   */
  payroll_GetPayrollById(id: string): Observable<GetPayrollByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/payroll/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPayroll_GetPayrollById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPayroll_GetPayrollById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetPayrollByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetPayrollByIdResponseModel>;
    }));
  }

  protected processPayroll_GetPayrollById(response: HttpResponseBase): Observable<GetPayrollByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetPayrollByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Delete payroll
   */
  payroll_DeletePayroll(id: string): Observable<DeletePayrollResponseModel> {
    let url_ = this.baseUrl + "/api/v1/payroll/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPayroll_DeletePayroll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPayroll_DeletePayroll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DeletePayrollResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DeletePayrollResponseModel>;
    }));
  }

  protected processPayroll_DeletePayroll(response: HttpResponseBase): Observable<DeletePayrollResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DeletePayrollResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create payroll summary for selected staff members for a specific month/year
   */
  payroll_CreatePayroll2(model: CreatePayrollSummaryRequestModel): Observable<CreatePayrollSummaryResponseModel> {
    let url_ = this.baseUrl + "/api/v1/payroll/summary";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPayroll_CreatePayroll2(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPayroll_CreatePayroll2(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreatePayrollSummaryResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreatePayrollSummaryResponseModel>;
    }));
  }

  protected processPayroll_CreatePayroll2(response: HttpResponseBase): Observable<CreatePayrollSummaryResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreatePayrollSummaryResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Approve payroll with payment proof upload
   */
  payroll_ApprovePayroll(id: string, model: ApprovePayrollRequestModel): Observable<ApprovePayrollResponseModel> {
    let url_ = this.baseUrl + "/api/v1/payroll/{id}/approve";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPayroll_ApprovePayroll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPayroll_ApprovePayroll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ApprovePayrollResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ApprovePayrollResponseModel>;
    }));
  }

  protected processPayroll_ApprovePayroll(response: HttpResponseBase): Observable<ApprovePayrollResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ApprovePayrollResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Reject payroll with reason
   */
  payroll_RejectPayroll(id: string, model: RejectPayrollRequestModel): Observable<RejectPayrollResponseModel> {
    let url_ = this.baseUrl + "/api/v1/payroll/{id}/reject";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPayroll_RejectPayroll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPayroll_RejectPayroll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RejectPayrollResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RejectPayrollResponseModel>;
    }));
  }

  protected processPayroll_RejectPayroll(response: HttpResponseBase): Observable<RejectPayrollResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RejectPayrollResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class PermissionClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all available permissions
   * @param type (optional) admin, company, or empty for both
   */
  permission_GetAllAvailablePermissions(type: string | null | undefined): Observable<GetAllAvailablePermissionsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/permissions?";
    if (type !== undefined && type !== null)
      url_ += "type=" + encodeURIComponent("" + type) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPermission_GetAllAvailablePermissions(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPermission_GetAllAvailablePermissions(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetAllAvailablePermissionsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetAllAvailablePermissionsResponseModel>;
    }));
  }

  protected processPermission_GetAllAvailablePermissions(response: HttpResponseBase): Observable<GetAllAvailablePermissionsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetAllAvailablePermissionsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class StaffAdminClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all admin staff with pagination
   * @param isEnabled (optional)
   * @param adminRoleId (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  staffAdmin_GetStaffAdmins(isEnabled: boolean | null | undefined, adminRoleId: string | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetStaffAdminsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/staff-admin?";
    if (isEnabled !== undefined && isEnabled !== null)
      url_ += "IsEnabled=" + encodeURIComponent("" + isEnabled) + "&";
    if (adminRoleId !== undefined && adminRoleId !== null)
      url_ += "AdminRoleId=" + encodeURIComponent("" + adminRoleId) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processStaffAdmin_GetStaffAdmins(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStaffAdmin_GetStaffAdmins(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetStaffAdminsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetStaffAdminsResponseModel>;
    }));
  }

  protected processStaffAdmin_GetStaffAdmins(response: HttpResponseBase): Observable<GetStaffAdminsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetStaffAdminsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create new admin staff
   */
  staffAdmin_CreateStaffAdmin(model: CreateStaffAdminRequestModel): Observable<CreateStaffAdminResponseModel> {
    let url_ = this.baseUrl + "/api/v1/staff-admin";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processStaffAdmin_CreateStaffAdmin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStaffAdmin_CreateStaffAdmin(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateStaffAdminResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateStaffAdminResponseModel>;
    }));
  }

  protected processStaffAdmin_CreateStaffAdmin(response: HttpResponseBase): Observable<CreateStaffAdminResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateStaffAdminResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get admin staff by ID
   */
  staffAdmin_GetStaffAdminById(id: string): Observable<GetStaffAdminByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/staff-admin/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processStaffAdmin_GetStaffAdminById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStaffAdmin_GetStaffAdminById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetStaffAdminByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetStaffAdminByIdResponseModel>;
    }));
  }

  protected processStaffAdmin_GetStaffAdminById(response: HttpResponseBase): Observable<GetStaffAdminByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetStaffAdminByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update existing admin staff
   */
  staffAdmin_UpdateStaffAdmin(id: string, model: UpdateStaffAdminRequestModel): Observable<UpdateStaffAdminResponseModel> {
    let url_ = this.baseUrl + "/api/v1/staff-admin/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processStaffAdmin_UpdateStaffAdmin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStaffAdmin_UpdateStaffAdmin(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateStaffAdminResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateStaffAdminResponseModel>;
    }));
  }

  protected processStaffAdmin_UpdateStaffAdmin(response: HttpResponseBase): Observable<UpdateStaffAdminResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateStaffAdminResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Delete admin staff
   */
  staffAdmin_DeleteStaffAdmin(id: string): Observable<DeleteStaffAdminResponseModel> {
    let url_ = this.baseUrl + "/api/v1/staff-admin/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processStaffAdmin_DeleteStaffAdmin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStaffAdmin_DeleteStaffAdmin(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DeleteStaffAdminResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DeleteStaffAdminResponseModel>;
    }));
  }

  protected processStaffAdmin_DeleteStaffAdmin(response: HttpResponseBase): Observable<DeleteStaffAdminResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DeleteStaffAdminResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get admin staff dropdown list
   */
  staffAdmin_GetStaffAdminsDropDown(): Observable<GetStaffAdminsDropDownResponseModel> {
    let url_ = this.baseUrl + "/api/v1/staff-admin/dropdown";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processStaffAdmin_GetStaffAdminsDropDown(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStaffAdmin_GetStaffAdminsDropDown(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetStaffAdminsDropDownResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetStaffAdminsDropDownResponseModel>;
    }));
  }

  protected processStaffAdmin_GetStaffAdminsDropDown(response: HttpResponseBase): Observable<GetStaffAdminsDropDownResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetStaffAdminsDropDownResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update current admin staff profile
   Requires: Authenticated admin staff
   */
  staffAdmin_UpdateStaffAdminProfile(model: UpdateStaffAdminProfileRequestModel): Observable<UpdateStaffAdminProfileResponseModel> {
    let url_ = this.baseUrl + "/api/v1/staff-admin/profile";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processStaffAdmin_UpdateStaffAdminProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStaffAdmin_UpdateStaffAdminProfile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateStaffAdminProfileResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateStaffAdminProfileResponseModel>;
    }));
  }

  protected processStaffAdmin_UpdateStaffAdminProfile(response: HttpResponseBase): Observable<UpdateStaffAdminProfileResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateStaffAdminProfileResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get current admin staff profile
   */
  staffAdmin_GetStaffAdminProfile(): Observable<GetStaffAdminProfileResponseModel> {
    let url_ = this.baseUrl + "/api/v1/staff-admin/profile";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processStaffAdmin_GetStaffAdminProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStaffAdmin_GetStaffAdminProfile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetStaffAdminProfileResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetStaffAdminProfileResponseModel>;
    }));
  }

  protected processStaffAdmin_GetStaffAdminProfile(response: HttpResponseBase): Observable<GetStaffAdminProfileResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetStaffAdminProfileResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class SubscriptionClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get All Subscriptions (Paginated)
   Requires: Administrator role OR ViewSubscriptionPlans permission
   * @param isActive (optional)
   * @param billingCycle (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  subscription_GetSubscriptions(isActive: boolean | null | undefined, billingCycle: BillingCycle | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetSubscriptionsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/subscriptions?";
    if (isActive !== undefined && isActive !== null)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (billingCycle !== undefined && billingCycle !== null)
      url_ += "BillingCycle=" + encodeURIComponent("" + billingCycle) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSubscription_GetSubscriptions(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSubscription_GetSubscriptions(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetSubscriptionsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetSubscriptionsResponseModel>;
    }));
  }

  protected processSubscription_GetSubscriptions(response: HttpResponseBase): Observable<GetSubscriptionsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetSubscriptionsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create Subscription Plan
   Requires: Administrator role OR CreateSubscriptionPlans permission
   */
  subscription_CreateSubscription(model: CreateSubscriptionRequestModel): Observable<CreateSubscriptionResponseModel> {
    let url_ = this.baseUrl + "/api/v1/subscriptions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSubscription_CreateSubscription(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSubscription_CreateSubscription(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateSubscriptionResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateSubscriptionResponseModel>;
    }));
  }

  protected processSubscription_CreateSubscription(response: HttpResponseBase): Observable<CreateSubscriptionResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateSubscriptionResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Subscriptions Drop Down
   Requires: Administrator role OR ViewSubscriptionPlans permission
   * @param search (optional)
   * @param limit (optional)
   * @param isActive (optional)
   */
  subscription_GetSubscriptionsDropDown(search: string | null | undefined, limit: number | null | undefined, isActive: boolean | null | undefined): Observable<GetSubscriptionsDropDownResponseModel> {
    let url_ = this.baseUrl + "/api/v1/subscriptions/dropDown?";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (limit !== undefined && limit !== null)
      url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
    if (isActive !== undefined && isActive !== null)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSubscription_GetSubscriptionsDropDown(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSubscription_GetSubscriptionsDropDown(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetSubscriptionsDropDownResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetSubscriptionsDropDownResponseModel>;
    }));
  }

  protected processSubscription_GetSubscriptionsDropDown(response: HttpResponseBase): Observable<GetSubscriptionsDropDownResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetSubscriptionsDropDownResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Active Subscriptions for a company
   */
  subscription_GetActiveSubscriptions(): Observable<GetActiveSubscriptionResponseModel> {
    let url_ = this.baseUrl + "/api/v1/subscriptions/active";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSubscription_GetActiveSubscriptions(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSubscription_GetActiveSubscriptions(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetActiveSubscriptionResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetActiveSubscriptionResponseModel>;
    }));
  }

  protected processSubscription_GetActiveSubscriptions(response: HttpResponseBase): Observable<GetActiveSubscriptionResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetActiveSubscriptionResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Subscription By Id
   Requires: Administrator role OR ViewSubscriptionPlans permission
   */
  subscription_GetSubscriptionById(id: string): Observable<GetSubscriptionByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/subscriptions/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSubscription_GetSubscriptionById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSubscription_GetSubscriptionById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetSubscriptionByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetSubscriptionByIdResponseModel>;
    }));
  }

  protected processSubscription_GetSubscriptionById(response: HttpResponseBase): Observable<GetSubscriptionByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetSubscriptionByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update Subscription Plan
   Requires: Administrator role OR UpdateSubscriptionPlans permission
   */
  subscription_UpdateSubscription(id: string, model: UpdateSubscriptionRequestModel): Observable<UpdateSubscriptionResponseModel> {
    let url_ = this.baseUrl + "/api/v1/subscriptions/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSubscription_UpdateSubscription(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSubscription_UpdateSubscription(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateSubscriptionResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateSubscriptionResponseModel>;
    }));
  }

  protected processSubscription_UpdateSubscription(response: HttpResponseBase): Observable<UpdateSubscriptionResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateSubscriptionResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Delete Subscription Plan (Soft Delete)
   Requires: Administrator role OR DeleteSubscriptionPlans permission
   */
  subscription_DeleteSubscription(id: string): Observable<DeleteSubscriptionResponseModel> {
    let url_ = this.baseUrl + "/api/v1/subscriptions/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSubscription_DeleteSubscription(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSubscription_DeleteSubscription(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DeleteSubscriptionResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DeleteSubscriptionResponseModel>;
    }));
  }

  protected processSubscription_DeleteSubscription(response: HttpResponseBase): Observable<DeleteSubscriptionResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DeleteSubscriptionResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class TempHoldClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all temp holds with pagination and filtering
   * @param month (optional)
   * @param year (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  tempHold_GetTempHolds(month: number | undefined, year: number | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetTempHoldsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/temp-holds?";
    if (month === null)
      throw new globalThis.Error("The parameter 'month' cannot be null.");
    else if (month !== undefined)
      url_ += "Month=" + encodeURIComponent("" + month) + "&";
    if (year === null)
      throw new globalThis.Error("The parameter 'year' cannot be null.");
    else if (year !== undefined)
      url_ += "Year=" + encodeURIComponent("" + year) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processTempHold_GetTempHolds(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processTempHold_GetTempHolds(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetTempHoldsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetTempHoldsResponseModel>;
    }));
  }

  protected processTempHold_GetTempHolds(response: HttpResponseBase): Observable<GetTempHoldsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetTempHoldsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create new temp hold
   */
  tempHold_CreateTempHold(model: CreateTempHoldRequestModel): Observable<CreateTempHoldResponseModel> {
    let url_ = this.baseUrl + "/api/v1/temp-holds";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processTempHold_CreateTempHold(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processTempHold_CreateTempHold(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateTempHoldResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateTempHoldResponseModel>;
    }));
  }

  protected processTempHold_CreateTempHold(response: HttpResponseBase): Observable<CreateTempHoldResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateTempHoldResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get temp hold by composite key (CompanyStaffId, Month, Year)
   */
  tempHold_GetTempHoldById(companyStaffId: string, month: number, year: number): Observable<GetTempHoldByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/temp-holds/{companyStaffId}/{month}/{year}";
    if (companyStaffId === undefined || companyStaffId === null)
      throw new globalThis.Error("The parameter 'companyStaffId' must be defined.");
    url_ = url_.replace("{companyStaffId}", encodeURIComponent("" + companyStaffId));
    if (month === undefined || month === null)
      throw new globalThis.Error("The parameter 'month' must be defined.");
    url_ = url_.replace("{month}", encodeURIComponent("" + month));
    if (year === undefined || year === null)
      throw new globalThis.Error("The parameter 'year' must be defined.");
    url_ = url_.replace("{year}", encodeURIComponent("" + year));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processTempHold_GetTempHoldById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processTempHold_GetTempHoldById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetTempHoldByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetTempHoldByIdResponseModel>;
    }));
  }

  protected processTempHold_GetTempHoldById(response: HttpResponseBase): Observable<GetTempHoldByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetTempHoldByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Delete temp hold by composite key (CompanyStaffId, Month, Year)
   */
  tempHold_DeleteTempHold(companyStaffId: string, month: number, year: number): Observable<DeleteTempHoldResponseModel> {
    let url_ = this.baseUrl + "/api/v1/temp-holds/{companyStaffId}/{month}/{year}";
    if (companyStaffId === undefined || companyStaffId === null)
      throw new globalThis.Error("The parameter 'companyStaffId' must be defined.");
    url_ = url_.replace("{companyStaffId}", encodeURIComponent("" + companyStaffId));
    if (month === undefined || month === null)
      throw new globalThis.Error("The parameter 'month' must be defined.");
    url_ = url_.replace("{month}", encodeURIComponent("" + month));
    if (year === undefined || year === null)
      throw new globalThis.Error("The parameter 'year' must be defined.");
    url_ = url_.replace("{year}", encodeURIComponent("" + year));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processTempHold_DeleteTempHold(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processTempHold_DeleteTempHold(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DeleteTempHoldResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DeleteTempHoldResponseModel>;
    }));
  }

  protected processTempHold_DeleteTempHold(response: HttpResponseBase): Observable<DeleteTempHoldResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DeleteTempHoldResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class TestClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Test Notification
   * @param tokens (optional)
   * @param topic (optional)
   * @param userId (optional)
   */
  test_SendNotification(tokens: string[] | null | undefined, topic: string | null | undefined, userId: string | null | undefined): Observable<SendTestNotificationResponseModel> {
    let url_ = this.baseUrl + "/api/v1/Test/notification?";
    if (tokens !== undefined && tokens !== null)
      tokens && tokens.forEach(item => { url_ += "Tokens=" + encodeURIComponent("" + item) + "&"; });
    if (topic !== undefined && topic !== null)
      url_ += "Topic=" + encodeURIComponent("" + topic) + "&";
    if (userId !== undefined && userId !== null)
      url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processTest_SendNotification(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processTest_SendNotification(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<SendTestNotificationResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<SendTestNotificationResponseModel>;
    }));
  }

  protected processTest_SendNotification(response: HttpResponseBase): Observable<SendTestNotificationResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SendTestNotificationResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class TransactionClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get all employee transactions with pagination and filters
   * @param type (optional)
   * @param payRollId (optional)
   * @param loanPaymentScheduleId (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  transaction_GetTransactionsEmployee(type: TransactionType | null | undefined, payRollId: string | null | undefined, loanPaymentScheduleId: string | null | undefined, fromDate: string | null | undefined, toDate: string | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetTransactionsEmployeeResponseModel> {
    let url_ = this.baseUrl + "/api/v1/transactions/employee?";
    if (type !== undefined && type !== null)
      url_ += "Type=" + encodeURIComponent("" + type) + "&";
    if (payRollId !== undefined && payRollId !== null)
      url_ += "PayRollId=" + encodeURIComponent("" + payRollId) + "&";
    if (loanPaymentScheduleId !== undefined && loanPaymentScheduleId !== null)
      url_ += "LoanPaymentScheduleId=" + encodeURIComponent("" + loanPaymentScheduleId) + "&";
    if (fromDate !== undefined && fromDate !== null)
      url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
    if (toDate !== undefined && toDate !== null)
      url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processTransaction_GetTransactionsEmployee(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processTransaction_GetTransactionsEmployee(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetTransactionsEmployeeResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetTransactionsEmployeeResponseModel>;
    }));
  }

  protected processTransaction_GetTransactionsEmployee(response: HttpResponseBase): Observable<GetTransactionsEmployeeResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetTransactionsEmployeeResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get all transactions with pagination and filters (tenant-filtered)
   * @param type (optional)
   * @param companyStaffId (optional)
   * @param payRollId (optional)
   * @param loanPaymentScheduleId (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  transaction_GetTransactions(type: TransactionType | null | undefined, companyStaffId: string | null | undefined, payRollId: string | null | undefined, loanPaymentScheduleId: string | null | undefined, fromDate: string | null | undefined, toDate: string | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetTransactionsResponseModel> {
    let url_ = this.baseUrl + "/api/v1/transactions?";
    if (type !== undefined && type !== null)
      url_ += "Type=" + encodeURIComponent("" + type) + "&";
    if (companyStaffId !== undefined && companyStaffId !== null)
      url_ += "CompanyStaffId=" + encodeURIComponent("" + companyStaffId) + "&";
    if (payRollId !== undefined && payRollId !== null)
      url_ += "PayRollId=" + encodeURIComponent("" + payRollId) + "&";
    if (loanPaymentScheduleId !== undefined && loanPaymentScheduleId !== null)
      url_ += "LoanPaymentScheduleId=" + encodeURIComponent("" + loanPaymentScheduleId) + "&";
    if (fromDate !== undefined && fromDate !== null)
      url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
    if (toDate !== undefined && toDate !== null)
      url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processTransaction_GetTransactions(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processTransaction_GetTransactions(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetTransactionsResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetTransactionsResponseModel>;
    }));
  }

  protected processTransaction_GetTransactions(response: HttpResponseBase): Observable<GetTransactionsResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetTransactionsResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get transaction by ID (tenant-filtered)
   */
  transaction_GetTransactionById(id: string): Observable<GetTransactionByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/transactions/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processTransaction_GetTransactionById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processTransaction_GetTransactionById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetTransactionByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetTransactionByIdResponseModel>;
    }));
  }

  protected processTransaction_GetTransactionById(response: HttpResponseBase): Observable<GetTransactionByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetTransactionByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root'
})
export class UserClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "http://localhost:5000";
  }

  /**
   * Get Users
   * @param role (optional)
   * @param isEnabled (optional)
   * @param isHideCount (optional)
   * @param search (optional)
   * @param isDescending (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @param orderBy (optional)
   */
  user_GetUsers(role: string | null | undefined, isEnabled: boolean | null | undefined, isHideCount: boolean | undefined, search: string | null | undefined, isDescending: boolean | undefined, page: number | undefined, pageSize: number | undefined, orderBy: string | null | undefined): Observable<GetUsersResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users?";
    if (role !== undefined && role !== null)
      url_ += "Role=" + encodeURIComponent("" + role) + "&";
    if (isEnabled !== undefined && isEnabled !== null)
      url_ += "IsEnabled=" + encodeURIComponent("" + isEnabled) + "&";
    if (isHideCount === null)
      throw new globalThis.Error("The parameter 'isHideCount' cannot be null.");
    else if (isHideCount !== undefined)
      url_ += "IsHideCount=" + encodeURIComponent("" + isHideCount) + "&";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (isDescending === null)
      throw new globalThis.Error("The parameter 'isDescending' cannot be null.");
    else if (isDescending !== undefined)
      url_ += "IsDescending=" + encodeURIComponent("" + isDescending) + "&";
    if (page === null)
      throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_GetUsers(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_GetUsers(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetUsersResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetUsersResponseModel>;
    }));
  }

  protected processUser_GetUsers(response: HttpResponseBase): Observable<GetUsersResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetUsersResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create User
   */
  user_CreateUser(model: CreateUserRequestModel): Observable<CreateUserResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_CreateUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_CreateUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateUserResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateUserResponseModel>;
    }));
  }

  protected processUser_CreateUser(response: HttpResponseBase): Observable<CreateUserResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateUserResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Change Current Password
   */
  user_ChangeCurrentPassword(model: ChangePasswordRequestModel): Observable<ChangePasswordResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/password";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_ChangeCurrentPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_ChangeCurrentPassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ChangePasswordResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ChangePasswordResponseModel>;
    }));
  }

  protected processUser_ChangeCurrentPassword(response: HttpResponseBase): Observable<ChangePasswordResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ChangePasswordResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update Password By Id of user
   */
  user_UpdatePasswordById(id: string, model: UpdatePasswordByIdRequestModel): Observable<UpdatePasswordByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/password/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_UpdatePasswordById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_UpdatePasswordById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdatePasswordByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdatePasswordByIdResponseModel>;
    }));
  }

  protected processUser_UpdatePasswordById(response: HttpResponseBase): Observable<UpdatePasswordByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdatePasswordByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get User Profile
   */
  user_GetUserProfile(): Observable<GetUserProfileResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/me";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_GetUserProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_GetUserProfile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetUserProfileResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetUserProfileResponseModel>;
    }));
  }

  protected processUser_GetUserProfile(response: HttpResponseBase): Observable<GetUserProfileResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetUserProfileResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update User Profile
   */
  user_UpdateUserProfile(model: UpdateUserProfileRequestModel): Observable<UpdateUserProfileResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/me";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_UpdateUserProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_UpdateUserProfile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateUserProfileResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateUserProfileResponseModel>;
    }));
  }

  protected processUser_UpdateUserProfile(response: HttpResponseBase): Observable<UpdateUserProfileResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateUserProfileResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get Users Drop Down
   * @param search (optional)
   * @param limit (optional)
   * @param role (optional)
   */
  user_GetUsersDropDown(search: string | null | undefined, limit: number | null | undefined, role: string | null | undefined): Observable<GetUsersDropDownResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/dropDown?";
    if (search !== undefined && search !== null)
      url_ += "Search=" + encodeURIComponent("" + search) + "&";
    if (limit !== undefined && limit !== null)
      url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
    if (role !== undefined && role !== null)
      url_ += "Role=" + encodeURIComponent("" + role) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_GetUsersDropDown(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_GetUsersDropDown(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetUsersDropDownResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetUsersDropDownResponseModel>;
    }));
  }

  protected processUser_GetUsersDropDown(response: HttpResponseBase): Observable<GetUsersDropDownResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetUsersDropDownResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Get User By Id
   */
  user_GetUserById(id: string): Observable<GetUserByIdResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_GetUserById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_GetUserById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetUserByIdResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetUserByIdResponseModel>;
    }));
  }

  protected processUser_GetUserById(response: HttpResponseBase): Observable<GetUserByIdResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetUserByIdResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Update User
   */
  user_UpdateUser(id: string, model: UpdateUserRequestModel): Observable<UpdateUserResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_UpdateUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_UpdateUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UpdateUserResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UpdateUserResponseModel>;
    }));
  }

  protected processUser_UpdateUser(response: HttpResponseBase): Observable<UpdateUserResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UpdateUserResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Delete User
   */
  user_DeleteUser(id: string): Observable<DeleteUserResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/{id}";
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_DeleteUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_DeleteUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DeleteUserResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DeleteUserResponseModel>;
    }));
  }

  protected processUser_DeleteUser(response: HttpResponseBase): Observable<DeleteUserResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DeleteUserResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create User Bulk
   */
  user_CreateUserBulk(model: CreateUserBulkRequestModel): Observable<CreateUserBulkResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/bulk";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_CreateUserBulk(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_CreateUserBulk(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateUserBulkResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateUserBulkResponseModel>;
    }));
  }

  protected processUser_CreateUserBulk(response: HttpResponseBase): Observable<CreateUserBulkResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateUserBulkResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Import User
   * @param file (optional)
   */
  user_ImportDocker(file: FileParameter[] | null | undefined): Observable<ImportUserBulkResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/import";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file !== null && file !== undefined)
      file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_ImportDocker(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_ImportDocker(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ImportUserBulkResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ImportUserBulkResponseModel>;
    }));
  }

  protected processUser_ImportDocker(response: HttpResponseBase): Observable<ImportUserBulkResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ImportUserBulkResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Create User with Link
   */
  user_CreateUserWithLink(model: CreateUserWithLinkRequestModel): Observable<CreateUserWithLinkResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/link";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_CreateUserWithLink(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_CreateUserWithLink(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CreateUserWithLinkResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CreateUserWithLinkResponseModel>;
    }));
  }

  protected processUser_CreateUserWithLink(response: HttpResponseBase): Observable<CreateUserWithLinkResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CreateUserWithLinkResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Reset Password
   */
  user_ResetPassword(model: ResetPasswordRequestModel): Observable<ResetPasswordResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/reset-password";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_ResetPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_ResetPassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ResetPasswordResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ResetPasswordResponseModel>;
    }));
  }

  protected processUser_ResetPassword(response: HttpResponseBase): Observable<ResetPasswordResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResetPasswordResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Generate Reset Token
   */
  user_GenerateResetPassword(model: GenerateResetPasswordTokenRequestModel): Observable<GenerateResetPasswordTokenResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/reset-token";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_GenerateResetPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_GenerateResetPassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GenerateResetPasswordTokenResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GenerateResetPasswordTokenResponseModel>;
    }));
  }

  protected processUser_GenerateResetPassword(response: HttpResponseBase): Observable<GenerateResetPasswordTokenResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GenerateResetPasswordTokenResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Checks if User is active or the company it belongs to is active
   */
  user_IsUserActive(): Observable<IsUserActiveResponseModel> {
    let url_ = this.baseUrl + "/api/v1/users/isActive";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUser_IsUserActive(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_IsUserActive(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<IsUserActiveResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<IsUserActiveResponseModel>;
    }));
  }

  protected processUser_IsUserActive(response: HttpResponseBase): Observable<IsUserActiveResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = IsUserActiveResponseModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export class GetAdminDashboardResponseModel implements IGetAdminDashboardResponseModel {
  kpi?: GetAdminDashboardKpiResponseModel | undefined;
  paymentsGraph?: GetAdminDashboardPaymentsGraphResponseModel | undefined;
  loanGraph?: GetAdminDashboardLoanGraphResponseModel | undefined;

  constructor(data?: IGetAdminDashboardResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.kpi = _data["kpi"] ? GetAdminDashboardKpiResponseModel.fromJS(_data["kpi"]) : undefined as any;
      this.paymentsGraph = _data["paymentsGraph"] ? GetAdminDashboardPaymentsGraphResponseModel.fromJS(_data["paymentsGraph"]) : undefined as any;
      this.loanGraph = _data["loanGraph"] ? GetAdminDashboardLoanGraphResponseModel.fromJS(_data["loanGraph"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetAdminDashboardResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetAdminDashboardResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["kpi"] = this.kpi ? this.kpi.toJSON() : undefined as any;
    data["paymentsGraph"] = this.paymentsGraph ? this.paymentsGraph.toJSON() : undefined as any;
    data["loanGraph"] = this.loanGraph ? this.loanGraph.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetAdminDashboardResponseModel {
  kpi?: GetAdminDashboardKpiResponseModel | undefined;
  paymentsGraph?: GetAdminDashboardPaymentsGraphResponseModel | undefined;
  loanGraph?: GetAdminDashboardLoanGraphResponseModel | undefined;
}

export class GetAdminDashboardKpiResponseModel implements IGetAdminDashboardKpiResponseModel {
  totalCompanies?: number;
  totalActiveSubscriptions?: number;
  totalPayments?: number;
  totalActiveStaff?: number;
  totalLoanAmountGiven?: number;

  constructor(data?: IGetAdminDashboardKpiResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCompanies = _data["totalCompanies"];
      this.totalActiveSubscriptions = _data["totalActiveSubscriptions"];
      this.totalPayments = _data["totalPayments"];
      this.totalActiveStaff = _data["totalActiveStaff"];
      this.totalLoanAmountGiven = _data["totalLoanAmountGiven"];
    }
  }

  static fromJS(data: any): GetAdminDashboardKpiResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetAdminDashboardKpiResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCompanies"] = this.totalCompanies;
    data["totalActiveSubscriptions"] = this.totalActiveSubscriptions;
    data["totalPayments"] = this.totalPayments;
    data["totalActiveStaff"] = this.totalActiveStaff;
    data["totalLoanAmountGiven"] = this.totalLoanAmountGiven;
    return data;
  }
}

export interface IGetAdminDashboardKpiResponseModel {
  totalCompanies?: number;
  totalActiveSubscriptions?: number;
  totalPayments?: number;
  totalActiveStaff?: number;
  totalLoanAmountGiven?: number;
}

export class GetAdminDashboardPaymentsGraphResponseModel implements IGetAdminDashboardPaymentsGraphResponseModel {
  dailyPaymentCounts?: DateCountModel[] | undefined;
  dailyPaymentSum?: DateCountModel[] | undefined;

  constructor(data?: IGetAdminDashboardPaymentsGraphResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["dailyPaymentCounts"])) {
        this.dailyPaymentCounts = [] as any;
        for (let item of _data["dailyPaymentCounts"])
          this.dailyPaymentCounts!.push(DateCountModel.fromJS(item));
      }
      if (Array.isArray(_data["dailyPaymentSum"])) {
        this.dailyPaymentSum = [] as any;
        for (let item of _data["dailyPaymentSum"])
          this.dailyPaymentSum!.push(DateCountModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetAdminDashboardPaymentsGraphResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetAdminDashboardPaymentsGraphResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.dailyPaymentCounts)) {
      data["dailyPaymentCounts"] = [];
      for (let item of this.dailyPaymentCounts)
        data["dailyPaymentCounts"].push(item ? item.toJSON() : undefined as any);
    }
    if (Array.isArray(this.dailyPaymentSum)) {
      data["dailyPaymentSum"] = [];
      for (let item of this.dailyPaymentSum)
        data["dailyPaymentSum"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetAdminDashboardPaymentsGraphResponseModel {
  dailyPaymentCounts?: DateCountModel[] | undefined;
  dailyPaymentSum?: DateCountModel[] | undefined;
}

export class DateCountModel implements IDateCountModel {
  date?: string | undefined;
  count?: number;

  constructor(data?: IDateCountModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data["date"];
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): DateCountModel {
    data = typeof data === 'object' ? data : {};
    let result = new DateCountModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["date"] = this.date;
    data["count"] = this.count;
    return data;
  }
}

export interface IDateCountModel {
  date?: string | undefined;
  count?: number;
}

export class GetAdminDashboardLoanGraphResponseModel implements IGetAdminDashboardLoanGraphResponseModel {
  dailyLoanRequestCounts?: DateCountModel[] | undefined;
  dailyLoanAmountSum?: DateCountModel[] | undefined;
  dailyApprovedLoanCounts?: DateCountModel[] | undefined;

  constructor(data?: IGetAdminDashboardLoanGraphResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["dailyLoanRequestCounts"])) {
        this.dailyLoanRequestCounts = [] as any;
        for (let item of _data["dailyLoanRequestCounts"])
          this.dailyLoanRequestCounts!.push(DateCountModel.fromJS(item));
      }
      if (Array.isArray(_data["dailyLoanAmountSum"])) {
        this.dailyLoanAmountSum = [] as any;
        for (let item of _data["dailyLoanAmountSum"])
          this.dailyLoanAmountSum!.push(DateCountModel.fromJS(item));
      }
      if (Array.isArray(_data["dailyApprovedLoanCounts"])) {
        this.dailyApprovedLoanCounts = [] as any;
        for (let item of _data["dailyApprovedLoanCounts"])
          this.dailyApprovedLoanCounts!.push(DateCountModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetAdminDashboardLoanGraphResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetAdminDashboardLoanGraphResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.dailyLoanRequestCounts)) {
      data["dailyLoanRequestCounts"] = [];
      for (let item of this.dailyLoanRequestCounts)
        data["dailyLoanRequestCounts"].push(item ? item.toJSON() : undefined as any);
    }
    if (Array.isArray(this.dailyLoanAmountSum)) {
      data["dailyLoanAmountSum"] = [];
      for (let item of this.dailyLoanAmountSum)
        data["dailyLoanAmountSum"].push(item ? item.toJSON() : undefined as any);
    }
    if (Array.isArray(this.dailyApprovedLoanCounts)) {
      data["dailyApprovedLoanCounts"] = [];
      for (let item of this.dailyApprovedLoanCounts)
        data["dailyApprovedLoanCounts"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetAdminDashboardLoanGraphResponseModel {
  dailyLoanRequestCounts?: DateCountModel[] | undefined;
  dailyLoanAmountSum?: DateCountModel[] | undefined;
  dailyApprovedLoanCounts?: DateCountModel[] | undefined;
}

export class GetAdminRolesResponseModel implements IGetAdminRolesResponseModel {
  data?: AdminRoleDto[] | undefined;
  count?: number;

  constructor(data?: IGetAdminRolesResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(AdminRoleDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetAdminRolesResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetAdminRolesResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetAdminRolesResponseModel {
  data?: AdminRoleDto[] | undefined;
  count?: number;
}

export class AdminRoleDto implements IAdminRoleDto {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  isActive?: boolean;
  userCount?: number;
  permissions?: string[] | undefined;
  createdDate?: string;

  constructor(data?: IAdminRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.isActive = _data["isActive"];
      this.userCount = _data["userCount"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions!.push(item);
      }
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): AdminRoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new AdminRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["description"] = this.description;
    data["isActive"] = this.isActive;
    data["userCount"] = this.userCount;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item);
    }
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface IAdminRoleDto {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  isActive?: boolean;
  userCount?: number;
  permissions?: string[] | undefined;
  createdDate?: string;
}

export class GetAdminRoleByIdResponseModel implements IGetAdminRoleByIdResponseModel {
  data?: AdminRoleDto | undefined;

  constructor(data?: IGetAdminRoleByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? AdminRoleDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetAdminRoleByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetAdminRoleByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetAdminRoleByIdResponseModel {
  data?: AdminRoleDto | undefined;
}

export class GetAdminRolesDropDownResponseModel implements IGetAdminRolesDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;

  constructor(data?: IGetAdminRolesDropDownResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(DropDownDtoOfString.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetAdminRolesDropDownResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetAdminRolesDropDownResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetAdminRolesDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;
}

export class DropDownDtoOfString implements IDropDownDtoOfString {
  id?: string | undefined;
  name?: string | undefined;

  constructor(data?: IDropDownDtoOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): DropDownDtoOfString {
    data = typeof data === 'object' ? data : {};
    let result = new DropDownDtoOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    return data;
  }
}

export interface IDropDownDtoOfString {
  id?: string | undefined;
  name?: string | undefined;
}

export class CreateAdminRoleResponseModel implements ICreateAdminRoleResponseModel {
  data?: AdminRoleDto | undefined;

  constructor(data?: ICreateAdminRoleResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? AdminRoleDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateAdminRoleResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateAdminRoleResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateAdminRoleResponseModel {
  data?: AdminRoleDto | undefined;
}

export class CreateAdminRoleRequestModel implements ICreateAdminRoleRequestModel {
  name?: string | undefined;
  description?: string | undefined;
  permissions?: string[] | undefined;

  constructor(data?: ICreateAdminRoleRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions!.push(item);
      }
    }
  }

  static fromJS(data: any): CreateAdminRoleRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateAdminRoleRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item);
    }
    return data;
  }
}

export interface ICreateAdminRoleRequestModel {
  name?: string | undefined;
  description?: string | undefined;
  permissions?: string[] | undefined;
}

export class UpdateAdminRoleResponseModel implements IUpdateAdminRoleResponseModel {
  data?: AdminRoleDto | undefined;

  constructor(data?: IUpdateAdminRoleResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? AdminRoleDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): UpdateAdminRoleResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateAdminRoleResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IUpdateAdminRoleResponseModel {
  data?: AdminRoleDto | undefined;
}

export class UpdateAdminRoleRequestModel implements IUpdateAdminRoleRequestModel {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  isActive?: boolean;
  permissions?: string[] | undefined;

  constructor(data?: IUpdateAdminRoleRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.isActive = _data["isActive"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions!.push(item);
      }
    }
  }

  static fromJS(data: any): UpdateAdminRoleRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateAdminRoleRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["description"] = this.description;
    data["isActive"] = this.isActive;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item);
    }
    return data;
  }
}

export interface IUpdateAdminRoleRequestModel {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  isActive?: boolean;
  permissions?: string[] | undefined;
}

export class DeleteAdminRoleResponseModel implements IDeleteAdminRoleResponseModel {
  success?: boolean;

  constructor(data?: IDeleteAdminRoleResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data["success"];
    }
  }

  static fromJS(data: any): DeleteAdminRoleResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteAdminRoleResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["success"] = this.success;
    return data;
  }
}

export interface IDeleteAdminRoleResponseModel {
  success?: boolean;
}

export class GetAuditLogsResponseModel implements IGetAuditLogsResponseModel {
  data?: AuditLogDto[] | undefined;
  count?: number;

  constructor(data?: IGetAuditLogsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(AuditLogDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetAuditLogsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetAuditLogsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetAuditLogsResponseModel {
  data?: AuditLogDto[] | undefined;
  count?: number;
}

export class AuditLogDto implements IAuditLogDto {
  user?: string | undefined;
  userId?: string | undefined;
  feature?: AuditLogFeatureType;
  action?: AuditLogType;
  description?: string | undefined;
  entityId?: string | undefined;
  createdDate?: string;

  constructor(data?: IAuditLogDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.user = _data["user"];
      this.userId = _data["userId"];
      this.feature = _data["feature"];
      this.action = _data["action"];
      this.description = _data["description"];
      this.entityId = _data["entityId"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): AuditLogDto {
    data = typeof data === 'object' ? data : {};
    let result = new AuditLogDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["user"] = this.user;
    data["userId"] = this.userId;
    data["feature"] = this.feature;
    data["action"] = this.action;
    data["description"] = this.description;
    data["entityId"] = this.entityId;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface IAuditLogDto {
  user?: string | undefined;
  userId?: string | undefined;
  feature?: AuditLogFeatureType;
  action?: AuditLogType;
  description?: string | undefined;
  entityId?: string | undefined;
  createdDate?: string;
}

export enum AuditLogFeatureType {
  User = 0,
  Subscription = 1,
  Company = 2,
}

export enum AuditLogType {
  Create = 0,
  Update = 1,
  Delete = 2,
  Approve = 3,
  Reject = 4,
}

export enum Lang {
  Eng = 0,
  Fr = 1,
}

export class GetCompanyAdminDashboardResponseModel implements IGetCompanyAdminDashboardResponseModel {
  kpi?: GetCompanyAdminDashboardKpiResponseModel | undefined;
  paymentsGraph?: GetCompanyAdminDashboardPaymentsGraphResponseModel | undefined;
  loanGraph?: GetCompanyAdminDashboardLoanGraphResponseModel | undefined;

  constructor(data?: IGetCompanyAdminDashboardResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.kpi = _data["kpi"] ? GetCompanyAdminDashboardKpiResponseModel.fromJS(_data["kpi"]) : undefined as any;
      this.paymentsGraph = _data["paymentsGraph"] ? GetCompanyAdminDashboardPaymentsGraphResponseModel.fromJS(_data["paymentsGraph"]) : undefined as any;
      this.loanGraph = _data["loanGraph"] ? GetCompanyAdminDashboardLoanGraphResponseModel.fromJS(_data["loanGraph"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetCompanyAdminDashboardResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyAdminDashboardResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["kpi"] = this.kpi ? this.kpi.toJSON() : undefined as any;
    data["paymentsGraph"] = this.paymentsGraph ? this.paymentsGraph.toJSON() : undefined as any;
    data["loanGraph"] = this.loanGraph ? this.loanGraph.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetCompanyAdminDashboardResponseModel {
  kpi?: GetCompanyAdminDashboardKpiResponseModel | undefined;
  paymentsGraph?: GetCompanyAdminDashboardPaymentsGraphResponseModel | undefined;
  loanGraph?: GetCompanyAdminDashboardLoanGraphResponseModel | undefined;
}

export class GetCompanyAdminDashboardKpiResponseModel implements IGetCompanyAdminDashboardKpiResponseModel {
  totalBranches?: number;
  totalActiveStaff?: number;
  totalLoanRequests?: number;
  totalApprovedLoans?: number;
  totalLoanAmountGiven?: number;
  totalPendingLoans?: number;
  totalRejectedLoans?: number;
  totalPayrolls?: number;

  constructor(data?: IGetCompanyAdminDashboardKpiResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalBranches = _data["totalBranches"];
      this.totalActiveStaff = _data["totalActiveStaff"];
      this.totalLoanRequests = _data["totalLoanRequests"];
      this.totalApprovedLoans = _data["totalApprovedLoans"];
      this.totalLoanAmountGiven = _data["totalLoanAmountGiven"];
      this.totalPendingLoans = _data["totalPendingLoans"];
      this.totalRejectedLoans = _data["totalRejectedLoans"];
      this.totalPayrolls = _data["totalPayrolls"];
    }
  }

  static fromJS(data: any): GetCompanyAdminDashboardKpiResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyAdminDashboardKpiResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalBranches"] = this.totalBranches;
    data["totalActiveStaff"] = this.totalActiveStaff;
    data["totalLoanRequests"] = this.totalLoanRequests;
    data["totalApprovedLoans"] = this.totalApprovedLoans;
    data["totalLoanAmountGiven"] = this.totalLoanAmountGiven;
    data["totalPendingLoans"] = this.totalPendingLoans;
    data["totalRejectedLoans"] = this.totalRejectedLoans;
    data["totalPayrolls"] = this.totalPayrolls;
    return data;
  }
}

export interface IGetCompanyAdminDashboardKpiResponseModel {
  totalBranches?: number;
  totalActiveStaff?: number;
  totalLoanRequests?: number;
  totalApprovedLoans?: number;
  totalLoanAmountGiven?: number;
  totalPendingLoans?: number;
  totalRejectedLoans?: number;
  totalPayrolls?: number;
}

export class GetCompanyAdminDashboardPaymentsGraphResponseModel implements IGetCompanyAdminDashboardPaymentsGraphResponseModel {
  dailyTransactionCounts?: DateCountModel[] | undefined;
  dailyTransactionSum?: DateCountModel[] | undefined;

  constructor(data?: IGetCompanyAdminDashboardPaymentsGraphResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["dailyTransactionCounts"])) {
        this.dailyTransactionCounts = [] as any;
        for (let item of _data["dailyTransactionCounts"])
          this.dailyTransactionCounts!.push(DateCountModel.fromJS(item));
      }
      if (Array.isArray(_data["dailyTransactionSum"])) {
        this.dailyTransactionSum = [] as any;
        for (let item of _data["dailyTransactionSum"])
          this.dailyTransactionSum!.push(DateCountModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetCompanyAdminDashboardPaymentsGraphResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyAdminDashboardPaymentsGraphResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.dailyTransactionCounts)) {
      data["dailyTransactionCounts"] = [];
      for (let item of this.dailyTransactionCounts)
        data["dailyTransactionCounts"].push(item ? item.toJSON() : undefined as any);
    }
    if (Array.isArray(this.dailyTransactionSum)) {
      data["dailyTransactionSum"] = [];
      for (let item of this.dailyTransactionSum)
        data["dailyTransactionSum"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetCompanyAdminDashboardPaymentsGraphResponseModel {
  dailyTransactionCounts?: DateCountModel[] | undefined;
  dailyTransactionSum?: DateCountModel[] | undefined;
}

export class GetCompanyAdminDashboardLoanGraphResponseModel implements IGetCompanyAdminDashboardLoanGraphResponseModel {
  dailyLoanRequestCounts?: DateCountModel[] | undefined;
  dailyLoanAmountSum?: DateCountModel[] | undefined;
  dailyApprovedLoanCounts?: DateCountModel[] | undefined;
  dailyPendingLoanCounts?: DateCountModel[] | undefined;
  dailyRejectedLoanCounts?: DateCountModel[] | undefined;

  constructor(data?: IGetCompanyAdminDashboardLoanGraphResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["dailyLoanRequestCounts"])) {
        this.dailyLoanRequestCounts = [] as any;
        for (let item of _data["dailyLoanRequestCounts"])
          this.dailyLoanRequestCounts!.push(DateCountModel.fromJS(item));
      }
      if (Array.isArray(_data["dailyLoanAmountSum"])) {
        this.dailyLoanAmountSum = [] as any;
        for (let item of _data["dailyLoanAmountSum"])
          this.dailyLoanAmountSum!.push(DateCountModel.fromJS(item));
      }
      if (Array.isArray(_data["dailyApprovedLoanCounts"])) {
        this.dailyApprovedLoanCounts = [] as any;
        for (let item of _data["dailyApprovedLoanCounts"])
          this.dailyApprovedLoanCounts!.push(DateCountModel.fromJS(item));
      }
      if (Array.isArray(_data["dailyPendingLoanCounts"])) {
        this.dailyPendingLoanCounts = [] as any;
        for (let item of _data["dailyPendingLoanCounts"])
          this.dailyPendingLoanCounts!.push(DateCountModel.fromJS(item));
      }
      if (Array.isArray(_data["dailyRejectedLoanCounts"])) {
        this.dailyRejectedLoanCounts = [] as any;
        for (let item of _data["dailyRejectedLoanCounts"])
          this.dailyRejectedLoanCounts!.push(DateCountModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetCompanyAdminDashboardLoanGraphResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyAdminDashboardLoanGraphResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.dailyLoanRequestCounts)) {
      data["dailyLoanRequestCounts"] = [];
      for (let item of this.dailyLoanRequestCounts)
        data["dailyLoanRequestCounts"].push(item ? item.toJSON() : undefined as any);
    }
    if (Array.isArray(this.dailyLoanAmountSum)) {
      data["dailyLoanAmountSum"] = [];
      for (let item of this.dailyLoanAmountSum)
        data["dailyLoanAmountSum"].push(item ? item.toJSON() : undefined as any);
    }
    if (Array.isArray(this.dailyApprovedLoanCounts)) {
      data["dailyApprovedLoanCounts"] = [];
      for (let item of this.dailyApprovedLoanCounts)
        data["dailyApprovedLoanCounts"].push(item ? item.toJSON() : undefined as any);
    }
    if (Array.isArray(this.dailyPendingLoanCounts)) {
      data["dailyPendingLoanCounts"] = [];
      for (let item of this.dailyPendingLoanCounts)
        data["dailyPendingLoanCounts"].push(item ? item.toJSON() : undefined as any);
    }
    if (Array.isArray(this.dailyRejectedLoanCounts)) {
      data["dailyRejectedLoanCounts"] = [];
      for (let item of this.dailyRejectedLoanCounts)
        data["dailyRejectedLoanCounts"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetCompanyAdminDashboardLoanGraphResponseModel {
  dailyLoanRequestCounts?: DateCountModel[] | undefined;
  dailyLoanAmountSum?: DateCountModel[] | undefined;
  dailyApprovedLoanCounts?: DateCountModel[] | undefined;
  dailyPendingLoanCounts?: DateCountModel[] | undefined;
  dailyRejectedLoanCounts?: DateCountModel[] | undefined;
}

export class GetCompanyBranchesResponseModel implements IGetCompanyBranchesResponseModel {
  data?: CompanyBranchDto[] | undefined;
  count?: number;

  constructor(data?: IGetCompanyBranchesResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(CompanyBranchDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetCompanyBranchesResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyBranchesResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetCompanyBranchesResponseModel {
  data?: CompanyBranchDto[] | undefined;
  count?: number;
}

export class CompanyBranchDto implements ICompanyBranchDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  name?: string | undefined;
  code?: string | undefined;
  phoneNumber?: string | undefined;
  address?: string | undefined;
  staffCount?: number;
  createdDate?: string;

  constructor(data?: ICompanyBranchDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyId = _data["companyId"];
      this.companyName = _data["companyName"];
      this.name = _data["name"];
      this.code = _data["code"];
      this.phoneNumber = _data["phoneNumber"];
      this.address = _data["address"];
      this.staffCount = _data["staffCount"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): CompanyBranchDto {
    data = typeof data === 'object' ? data : {};
    let result = new CompanyBranchDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["companyId"] = this.companyId;
    data["companyName"] = this.companyName;
    data["name"] = this.name;
    data["code"] = this.code;
    data["phoneNumber"] = this.phoneNumber;
    data["address"] = this.address;
    data["staffCount"] = this.staffCount;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface ICompanyBranchDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  name?: string | undefined;
  code?: string | undefined;
  phoneNumber?: string | undefined;
  address?: string | undefined;
  staffCount?: number;
  createdDate?: string;
}

export class GetCompanyBranchByIdResponseModel implements IGetCompanyBranchByIdResponseModel {
  data?: CompanyBranchDto | undefined;

  constructor(data?: IGetCompanyBranchByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyBranchDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetCompanyBranchByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyBranchByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetCompanyBranchByIdResponseModel {
  data?: CompanyBranchDto | undefined;
}

export class GetCompanyBranchesDropDownResponseModel implements IGetCompanyBranchesDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;

  constructor(data?: IGetCompanyBranchesDropDownResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(DropDownDtoOfString.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetCompanyBranchesDropDownResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyBranchesDropDownResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetCompanyBranchesDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;
}

export class CreateCompanyBranchResponseModel implements ICreateCompanyBranchResponseModel {
  data?: CompanyBranchDto | undefined;

  constructor(data?: ICreateCompanyBranchResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyBranchDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateCompanyBranchResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCompanyBranchResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateCompanyBranchResponseModel {
  data?: CompanyBranchDto | undefined;
}

export class CreateCompanyBranchRequestModel implements ICreateCompanyBranchRequestModel {
  name?: string | undefined;
  code?: string | undefined;
  phoneNumber?: string | undefined;
  address?: string | undefined;

  constructor(data?: ICreateCompanyBranchRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.code = _data["code"];
      this.phoneNumber = _data["phoneNumber"];
      this.address = _data["address"];
    }
  }

  static fromJS(data: any): CreateCompanyBranchRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCompanyBranchRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["code"] = this.code;
    data["phoneNumber"] = this.phoneNumber;
    data["address"] = this.address;
    return data;
  }
}

export interface ICreateCompanyBranchRequestModel {
  name?: string | undefined;
  code?: string | undefined;
  phoneNumber?: string | undefined;
  address?: string | undefined;
}

export class UpdateCompanyBranchResponseModel implements IUpdateCompanyBranchResponseModel {
  data?: CompanyBranchDto | undefined;

  constructor(data?: IUpdateCompanyBranchResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyBranchDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): UpdateCompanyBranchResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyBranchResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IUpdateCompanyBranchResponseModel {
  data?: CompanyBranchDto | undefined;
}

export class UpdateCompanyBranchRequestModel implements IUpdateCompanyBranchRequestModel {
  id?: string | undefined;
  name?: string | undefined;
  code?: string | undefined;
  phoneNumber?: string | undefined;
  address?: string | undefined;

  constructor(data?: IUpdateCompanyBranchRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.code = _data["code"];
      this.phoneNumber = _data["phoneNumber"];
      this.address = _data["address"];
    }
  }

  static fromJS(data: any): UpdateCompanyBranchRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyBranchRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["code"] = this.code;
    data["phoneNumber"] = this.phoneNumber;
    data["address"] = this.address;
    return data;
  }
}

export interface IUpdateCompanyBranchRequestModel {
  id?: string | undefined;
  name?: string | undefined;
  code?: string | undefined;
  phoneNumber?: string | undefined;
  address?: string | undefined;
}

export class DeleteCompanyBranchResponseModel implements IDeleteCompanyBranchResponseModel {
  success?: boolean;

  constructor(data?: IDeleteCompanyBranchResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data["success"];
    }
  }

  static fromJS(data: any): DeleteCompanyBranchResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteCompanyBranchResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["success"] = this.success;
    return data;
  }
}

export interface IDeleteCompanyBranchResponseModel {
  success?: boolean;
}

export class RegisterCompanyResponseModel implements IRegisterCompanyResponseModel {
  data?: CompanyDto | undefined;
  message?: string | undefined;

  constructor(data?: IRegisterCompanyResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyDto.fromJS(_data["data"]) : undefined as any;
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): RegisterCompanyResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterCompanyResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    data["message"] = this.message;
    return data;
  }
}

export interface IRegisterCompanyResponseModel {
  data?: CompanyDto | undefined;
  message?: string | undefined;
}

export class CompanyDto implements ICompanyDto {
  id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  companyName?: string | undefined;
  status?: RequestStatus;
  subscriptionId?: string | undefined;
  subscriptionPlanName?: string | undefined;
  subscriptionStartDate?: string | undefined;
  subscriptionEndDate?: string | undefined;
  subscriptionActive?: boolean;
  isActive?: boolean;
  createdDate?: string;

  constructor(data?: ICompanyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.companyName = _data["companyName"];
      this.status = _data["status"];
      this.subscriptionId = _data["subscriptionId"];
      this.subscriptionPlanName = _data["subscriptionPlanName"];
      this.subscriptionStartDate = _data["subscriptionStartDate"];
      this.subscriptionEndDate = _data["subscriptionEndDate"];
      this.subscriptionActive = _data["subscriptionActive"];
      this.isActive = _data["isActive"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): CompanyDto {
    data = typeof data === 'object' ? data : {};
    let result = new CompanyDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["companyName"] = this.companyName;
    data["status"] = this.status;
    data["subscriptionId"] = this.subscriptionId;
    data["subscriptionPlanName"] = this.subscriptionPlanName;
    data["subscriptionStartDate"] = this.subscriptionStartDate;
    data["subscriptionEndDate"] = this.subscriptionEndDate;
    data["subscriptionActive"] = this.subscriptionActive;
    data["isActive"] = this.isActive;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface ICompanyDto {
  id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  companyName?: string | undefined;
  status?: RequestStatus;
  subscriptionId?: string | undefined;
  subscriptionPlanName?: string | undefined;
  subscriptionStartDate?: string | undefined;
  subscriptionEndDate?: string | undefined;
  subscriptionActive?: boolean;
  isActive?: boolean;
  createdDate?: string;
}

export enum RequestStatus {
  Pending = 0,
  Approved = 1,
  Rejected = 2,
}

export class RegisterCompanyRequestModel implements IRegisterCompanyRequestModel {
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  companyName?: string | undefined;
  businessRegistrationCertificate?: string | undefined;
  vatCertificate?: string | undefined;
  authorizationIdProof?: string | undefined;

  constructor(data?: IRegisterCompanyRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.companyName = _data["companyName"];
      this.businessRegistrationCertificate = _data["businessRegistrationCertificate"];
      this.vatCertificate = _data["vatCertificate"];
      this.authorizationIdProof = _data["authorizationIdProof"];
    }
  }

  static fromJS(data: any): RegisterCompanyRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterCompanyRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["companyName"] = this.companyName;
    data["businessRegistrationCertificate"] = this.businessRegistrationCertificate;
    data["vatCertificate"] = this.vatCertificate;
    data["authorizationIdProof"] = this.authorizationIdProof;
    return data;
  }
}

export interface IRegisterCompanyRequestModel {
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  companyName?: string | undefined;
  businessRegistrationCertificate?: string | undefined;
  vatCertificate?: string | undefined;
  authorizationIdProof?: string | undefined;
}

export class GetCompaniesResponseModel implements IGetCompaniesResponseModel {
  data?: CompanyDto[] | undefined;
  count?: number;

  constructor(data?: IGetCompaniesResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(CompanyDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetCompaniesResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompaniesResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetCompaniesResponseModel {
  data?: CompanyDto[] | undefined;
  count?: number;
}

export class GetCompanyProfileResponseModel implements IGetCompanyProfileResponseModel {
  data?: CompanyProfileDto | undefined;

  constructor(data?: IGetCompanyProfileResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyProfileDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetCompanyProfileResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyProfileResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetCompanyProfileResponseModel {
  data?: CompanyProfileDto | undefined;
}

export class CompanyProfileDto implements ICompanyProfileDto {
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  companyName?: string | undefined;
  companyLogo?: string | undefined;

  constructor(data?: ICompanyProfileDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.companyName = _data["companyName"];
      this.companyLogo = _data["companyLogo"];
    }
  }

  static fromJS(data: any): CompanyProfileDto {
    data = typeof data === 'object' ? data : {};
    let result = new CompanyProfileDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["companyName"] = this.companyName;
    data["companyLogo"] = this.companyLogo;
    return data;
  }
}

export interface ICompanyProfileDto {
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  companyName?: string | undefined;
  companyLogo?: string | undefined;
}

export class GetCompanyByIdResponseModel implements IGetCompanyByIdResponseModel {
  data?: CompanyDto | undefined;

  constructor(data?: IGetCompanyByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetCompanyByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetCompanyByIdResponseModel {
  data?: CompanyDto | undefined;
}

export class GetCompanyDetailByIdResponseModel implements IGetCompanyDetailByIdResponseModel {
  data?: CompanyDetailDto | undefined;

  constructor(data?: IGetCompanyDetailByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyDetailDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetCompanyDetailByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyDetailByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetCompanyDetailByIdResponseModel {
  data?: CompanyDetailDto | undefined;
}

export class CompanyDetailDto extends CompanyDto implements ICompanyDetailDto {
  businessRegistrationCertificate?: string | undefined;
  vatCertificate?: string | undefined;
  authorizationIdProof?: string | undefined;
  approvedByUserId?: string | undefined;
  approvedByUserName?: string | undefined;
  approvedDate?: string | undefined;
  rejectedByUserId?: string | undefined;
  rejectedByUserName?: string | undefined;
  rejectedDate?: string | undefined;
  adminNotes?: string | undefined;
  companyAdminUserId?: string | undefined;
  companyLogo?: string | undefined;

  constructor(data?: ICompanyDetailDto) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.businessRegistrationCertificate = _data["businessRegistrationCertificate"];
      this.vatCertificate = _data["vatCertificate"];
      this.authorizationIdProof = _data["authorizationIdProof"];
      this.approvedByUserId = _data["approvedByUserId"];
      this.approvedByUserName = _data["approvedByUserName"];
      this.approvedDate = _data["approvedDate"];
      this.rejectedByUserId = _data["rejectedByUserId"];
      this.rejectedByUserName = _data["rejectedByUserName"];
      this.rejectedDate = _data["rejectedDate"];
      this.adminNotes = _data["adminNotes"];
      this.companyAdminUserId = _data["companyAdminUserId"];
      this.companyLogo = _data["companyLogo"];
    }
  }

  static override fromJS(data: any): CompanyDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new CompanyDetailDto();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["businessRegistrationCertificate"] = this.businessRegistrationCertificate;
    data["vatCertificate"] = this.vatCertificate;
    data["authorizationIdProof"] = this.authorizationIdProof;
    data["approvedByUserId"] = this.approvedByUserId;
    data["approvedByUserName"] = this.approvedByUserName;
    data["approvedDate"] = this.approvedDate;
    data["rejectedByUserId"] = this.rejectedByUserId;
    data["rejectedByUserName"] = this.rejectedByUserName;
    data["rejectedDate"] = this.rejectedDate;
    data["adminNotes"] = this.adminNotes;
    data["companyAdminUserId"] = this.companyAdminUserId;
    data["companyLogo"] = this.companyLogo;
    super.toJSON(data);
    return data;
  }
}

export interface ICompanyDetailDto extends ICompanyDto {
  businessRegistrationCertificate?: string | undefined;
  vatCertificate?: string | undefined;
  authorizationIdProof?: string | undefined;
  approvedByUserId?: string | undefined;
  approvedByUserName?: string | undefined;
  approvedDate?: string | undefined;
  rejectedByUserId?: string | undefined;
  rejectedByUserName?: string | undefined;
  rejectedDate?: string | undefined;
  adminNotes?: string | undefined;
  companyAdminUserId?: string | undefined;
  companyLogo?: string | undefined;
}

export class ApproveCompanyResponseModel implements IApproveCompanyResponseModel {
  data?: CompanyDto | undefined;
  message?: string | undefined;

  constructor(data?: IApproveCompanyResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyDto.fromJS(_data["data"]) : undefined as any;
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): ApproveCompanyResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new ApproveCompanyResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    data["message"] = this.message;
    return data;
  }
}

export interface IApproveCompanyResponseModel {
  data?: CompanyDto | undefined;
  message?: string | undefined;
}

export class ApproveCompanyRequestModel implements IApproveCompanyRequestModel {
  id?: string | undefined;
  adminNotes?: string | undefined;

  constructor(data?: IApproveCompanyRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.adminNotes = _data["adminNotes"];
    }
  }

  static fromJS(data: any): ApproveCompanyRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new ApproveCompanyRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["adminNotes"] = this.adminNotes;
    return data;
  }
}

export interface IApproveCompanyRequestModel {
  id?: string | undefined;
  adminNotes?: string | undefined;
}

export class RejectCompanyResponseModel implements IRejectCompanyResponseModel {
  data?: CompanyDto | undefined;
  message?: string | undefined;

  constructor(data?: IRejectCompanyResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyDto.fromJS(_data["data"]) : undefined as any;
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): RejectCompanyResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new RejectCompanyResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    data["message"] = this.message;
    return data;
  }
}

export interface IRejectCompanyResponseModel {
  data?: CompanyDto | undefined;
  message?: string | undefined;
}

export class RejectCompanyRequestModel implements IRejectCompanyRequestModel {
  id?: string | undefined;
  adminNotes?: string | undefined;

  constructor(data?: IRejectCompanyRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.adminNotes = _data["adminNotes"];
    }
  }

  static fromJS(data: any): RejectCompanyRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new RejectCompanyRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["adminNotes"] = this.adminNotes;
    return data;
  }
}

export interface IRejectCompanyRequestModel {
  id?: string | undefined;
  adminNotes?: string | undefined;
}

export class AssignSubscriptionResponseModel implements IAssignSubscriptionResponseModel {
  data?: CompanyDto | undefined;
  message?: string | undefined;

  constructor(data?: IAssignSubscriptionResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyDto.fromJS(_data["data"]) : undefined as any;
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): AssignSubscriptionResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new AssignSubscriptionResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    data["message"] = this.message;
    return data;
  }
}

export interface IAssignSubscriptionResponseModel {
  data?: CompanyDto | undefined;
  message?: string | undefined;
}

export class AssignSubscriptionRequestModel implements IAssignSubscriptionRequestModel {
  companyId?: string | undefined;
  subscriptionId?: string | undefined;
  durationMonths?: number;

  constructor(data?: IAssignSubscriptionRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.companyId = _data["companyId"];
      this.subscriptionId = _data["subscriptionId"];
      this.durationMonths = _data["durationMonths"];
    }
  }

  static fromJS(data: any): AssignSubscriptionRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new AssignSubscriptionRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["companyId"] = this.companyId;
    data["subscriptionId"] = this.subscriptionId;
    data["durationMonths"] = this.durationMonths;
    return data;
  }
}

export interface IAssignSubscriptionRequestModel {
  companyId?: string | undefined;
  subscriptionId?: string | undefined;
  durationMonths?: number;
}

export class CheckUserActiveStatusResponseModel implements ICheckUserActiveStatusResponseModel {
  isUserActive?: boolean;
  isCompanyActive?: boolean;
  companyId?: string | undefined;
  companyName?: string | undefined;
  message?: string | undefined;

  constructor(data?: ICheckUserActiveStatusResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isUserActive = _data["isUserActive"];
      this.isCompanyActive = _data["isCompanyActive"];
      this.companyId = _data["companyId"];
      this.companyName = _data["companyName"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): CheckUserActiveStatusResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CheckUserActiveStatusResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["isUserActive"] = this.isUserActive;
    data["isCompanyActive"] = this.isCompanyActive;
    data["companyId"] = this.companyId;
    data["companyName"] = this.companyName;
    data["message"] = this.message;
    return data;
  }
}

export interface ICheckUserActiveStatusResponseModel {
  isUserActive?: boolean;
  isCompanyActive?: boolean;
  companyId?: string | undefined;
  companyName?: string | undefined;
  message?: string | undefined;
}

export class CheckUserSubscriptionResponseModel implements ICheckUserSubscriptionResponseModel {
  hasSubscription?: boolean;
  hasRequested?: boolean;
  isExpired?: boolean;
  companyId?: string | undefined;
  companyName?: string | undefined;
  subscriptionId?: string | undefined;
  subscriptionPlanName?: string | undefined;
  subscriptionStartDate?: string | undefined;
  subscriptionEndDate?: string | undefined;
  daysRemaining?: number | undefined;
  maxUsersAllowed?: number | undefined;
  maxBranches?: number | undefined;
  message?: string | undefined;

  constructor(data?: ICheckUserSubscriptionResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.hasSubscription = _data["hasSubscription"];
      this.hasRequested = _data["hasRequested"];
      this.isExpired = _data["isExpired"];
      this.companyId = _data["companyId"];
      this.companyName = _data["companyName"];
      this.subscriptionId = _data["subscriptionId"];
      this.subscriptionPlanName = _data["subscriptionPlanName"];
      this.subscriptionStartDate = _data["subscriptionStartDate"];
      this.subscriptionEndDate = _data["subscriptionEndDate"];
      this.daysRemaining = _data["daysRemaining"];
      this.maxUsersAllowed = _data["maxUsersAllowed"];
      this.maxBranches = _data["maxBranches"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): CheckUserSubscriptionResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CheckUserSubscriptionResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["hasSubscription"] = this.hasSubscription;
    data["hasRequested"] = this.hasRequested;
    data["isExpired"] = this.isExpired;
    data["companyId"] = this.companyId;
    data["companyName"] = this.companyName;
    data["subscriptionId"] = this.subscriptionId;
    data["subscriptionPlanName"] = this.subscriptionPlanName;
    data["subscriptionStartDate"] = this.subscriptionStartDate;
    data["subscriptionEndDate"] = this.subscriptionEndDate;
    data["daysRemaining"] = this.daysRemaining;
    data["maxUsersAllowed"] = this.maxUsersAllowed;
    data["maxBranches"] = this.maxBranches;
    data["message"] = this.message;
    return data;
  }
}

export interface ICheckUserSubscriptionResponseModel {
  hasSubscription?: boolean;
  hasRequested?: boolean;
  isExpired?: boolean;
  companyId?: string | undefined;
  companyName?: string | undefined;
  subscriptionId?: string | undefined;
  subscriptionPlanName?: string | undefined;
  subscriptionStartDate?: string | undefined;
  subscriptionEndDate?: string | undefined;
  daysRemaining?: number | undefined;
  maxUsersAllowed?: number | undefined;
  maxBranches?: number | undefined;
  message?: string | undefined;
}

export class UpdateCompanyProfileResponseModel implements IUpdateCompanyProfileResponseModel {
  data?: CompanyDto | undefined;
  message?: string | undefined;

  constructor(data?: IUpdateCompanyProfileResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyDto.fromJS(_data["data"]) : undefined as any;
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): UpdateCompanyProfileResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyProfileResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    data["message"] = this.message;
    return data;
  }
}

export interface IUpdateCompanyProfileResponseModel {
  data?: CompanyDto | undefined;
  message?: string | undefined;
}

export class UpdateCompanyProfileRequestModel implements IUpdateCompanyProfileRequestModel {
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  companyName?: string | undefined;
  companyLogo?: string | undefined;

  constructor(data?: IUpdateCompanyProfileRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.companyName = _data["companyName"];
      this.companyLogo = _data["companyLogo"];
    }
  }

  static fromJS(data: any): UpdateCompanyProfileRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyProfileRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["companyName"] = this.companyName;
    data["companyLogo"] = this.companyLogo;
    return data;
  }
}

export interface IUpdateCompanyProfileRequestModel {
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  companyName?: string | undefined;
  companyLogo?: string | undefined;
}

export class GetCompanyRolesResponseModel implements IGetCompanyRolesResponseModel {
  data?: CompanyRoleDto[] | undefined;
  count?: number;

  constructor(data?: IGetCompanyRolesResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(CompanyRoleDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetCompanyRolesResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyRolesResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetCompanyRolesResponseModel {
  data?: CompanyRoleDto[] | undefined;
  count?: number;
}

export class CompanyRoleDto implements ICompanyRoleDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  isActive?: boolean;
  userCount?: number;
  permissions?: string[] | undefined;
  createdDate?: string;

  constructor(data?: ICompanyRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyId = _data["companyId"];
      this.companyName = _data["companyName"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.isActive = _data["isActive"];
      this.userCount = _data["userCount"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions!.push(item);
      }
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): CompanyRoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new CompanyRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["companyId"] = this.companyId;
    data["companyName"] = this.companyName;
    data["name"] = this.name;
    data["description"] = this.description;
    data["isActive"] = this.isActive;
    data["userCount"] = this.userCount;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item);
    }
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface ICompanyRoleDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  isActive?: boolean;
  userCount?: number;
  permissions?: string[] | undefined;
  createdDate?: string;
}

export class GetCompanyRoleByIdResponseModel implements IGetCompanyRoleByIdResponseModel {
  data?: CompanyRoleDto | undefined;

  constructor(data?: IGetCompanyRoleByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyRoleDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetCompanyRoleByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyRoleByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetCompanyRoleByIdResponseModel {
  data?: CompanyRoleDto | undefined;
}

export class GetCompanyRolesDropDownResponseModel implements IGetCompanyRolesDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;

  constructor(data?: IGetCompanyRolesDropDownResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(DropDownDtoOfString.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetCompanyRolesDropDownResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyRolesDropDownResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetCompanyRolesDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;
}

export class CreateCompanyRoleResponseModel implements ICreateCompanyRoleResponseModel {
  data?: CompanyRoleDto | undefined;

  constructor(data?: ICreateCompanyRoleResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyRoleDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateCompanyRoleResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCompanyRoleResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateCompanyRoleResponseModel {
  data?: CompanyRoleDto | undefined;
}

export class CreateCompanyRoleRequestModel implements ICreateCompanyRoleRequestModel {
  name?: string | undefined;
  description?: string | undefined;
  permissions?: string[] | undefined;

  constructor(data?: ICreateCompanyRoleRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions!.push(item);
      }
    }
  }

  static fromJS(data: any): CreateCompanyRoleRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCompanyRoleRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item);
    }
    return data;
  }
}

export interface ICreateCompanyRoleRequestModel {
  name?: string | undefined;
  description?: string | undefined;
  permissions?: string[] | undefined;
}

export class UpdateCompanyRoleResponseModel implements IUpdateCompanyRoleResponseModel {
  data?: CompanyRoleDto | undefined;

  constructor(data?: IUpdateCompanyRoleResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyRoleDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): UpdateCompanyRoleResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyRoleResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IUpdateCompanyRoleResponseModel {
  data?: CompanyRoleDto | undefined;
}

export class UpdateCompanyRoleRequestModel implements IUpdateCompanyRoleRequestModel {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  isActive?: boolean;
  permissions?: string[] | undefined;

  constructor(data?: IUpdateCompanyRoleRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.isActive = _data["isActive"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions!.push(item);
      }
    }
  }

  static fromJS(data: any): UpdateCompanyRoleRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyRoleRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["description"] = this.description;
    data["isActive"] = this.isActive;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item);
    }
    return data;
  }
}

export interface IUpdateCompanyRoleRequestModel {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  isActive?: boolean;
  permissions?: string[] | undefined;
}

export class DeleteCompanyRoleResponseModel implements IDeleteCompanyRoleResponseModel {
  success?: boolean;

  constructor(data?: IDeleteCompanyRoleResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data["success"];
    }
  }

  static fromJS(data: any): DeleteCompanyRoleResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteCompanyRoleResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["success"] = this.success;
    return data;
  }
}

export interface IDeleteCompanyRoleResponseModel {
  success?: boolean;
}

export class GetCompanySettingsResponseModel implements IGetCompanySettingsResponseModel {
  data?: CompanySettingDto[] | undefined;

  constructor(data?: IGetCompanySettingsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(CompanySettingDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetCompanySettingsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanySettingsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetCompanySettingsResponseModel {
  data?: CompanySettingDto[] | undefined;
}

export class CompanySettingDto implements ICompanySettingDto {
  key?: string | undefined;
  value?: string | undefined;

  constructor(data?: ICompanySettingDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data["key"];
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): CompanySettingDto {
    data = typeof data === 'object' ? data : {};
    let result = new CompanySettingDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["key"] = this.key;
    data["value"] = this.value;
    return data;
  }
}

export interface ICompanySettingDto {
  key?: string | undefined;
  value?: string | undefined;
}

export class UpdateCompanySettingsResponseModel implements IUpdateCompanySettingsResponseModel {
  data?: CompanySettingDto[] | undefined;
  message?: string | undefined;

  constructor(data?: IUpdateCompanySettingsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(CompanySettingDto.fromJS(item));
      }
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): UpdateCompanySettingsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanySettingsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["message"] = this.message;
    return data;
  }
}

export interface IUpdateCompanySettingsResponseModel {
  data?: CompanySettingDto[] | undefined;
  message?: string | undefined;
}

export class UpdateCompanySettingsRequestModel implements IUpdateCompanySettingsRequestModel {
  settings?: { [key: string]: string; } | undefined;

  constructor(data?: IUpdateCompanySettingsRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data["settings"]) {
        this.settings = {} as any;
        for (let key in _data["settings"]) {
          if (_data["settings"].hasOwnProperty(key))
            (this.settings as any)![key] = _data["settings"][key];
        }
      }
    }
  }

  static fromJS(data: any): UpdateCompanySettingsRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanySettingsRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.settings) {
      data["settings"] = {};
      for (let key in this.settings) {
        if (this.settings.hasOwnProperty(key))
          (data["settings"] as any)[key] = (this.settings as any)[key];
      }
    }
    return data;
  }
}

export interface IUpdateCompanySettingsRequestModel {
  settings?: { [key: string]: string; } | undefined;
}

export class GetCompanySettingsPublicResponseModel implements IGetCompanySettingsPublicResponseModel {
  data?: CompanySettingDto[] | undefined;

  constructor(data?: IGetCompanySettingsPublicResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(CompanySettingDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetCompanySettingsPublicResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanySettingsPublicResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetCompanySettingsPublicResponseModel {
  data?: CompanySettingDto[] | undefined;
}

export class GetCompanyStaffsResponseModel implements IGetCompanyStaffsResponseModel {
  data?: CompanyStaffDto[] | undefined;
  count?: number;

  constructor(data?: IGetCompanyStaffsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(CompanyStaffDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetCompanyStaffsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyStaffsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetCompanyStaffsResponseModel {
  data?: CompanyStaffDto[] | undefined;
  count?: number;
}

export class CompanyStaffDto implements ICompanyStaffDto {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  isEnabled?: boolean;
  branchId?: string | undefined;
  branchName?: string | undefined;
  salary?: number;
  companyRoleId?: string | undefined;
  companyRoleName?: string | undefined;
  createdDate?: string;

  constructor(data?: ICompanyStaffDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.image = _data["image"];
      this.isEnabled = _data["isEnabled"];
      this.branchId = _data["branchId"];
      this.branchName = _data["branchName"];
      this.salary = _data["salary"];
      this.companyRoleId = _data["companyRoleId"];
      this.companyRoleName = _data["companyRoleName"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): CompanyStaffDto {
    data = typeof data === 'object' ? data : {};
    let result = new CompanyStaffDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["image"] = this.image;
    data["isEnabled"] = this.isEnabled;
    data["branchId"] = this.branchId;
    data["branchName"] = this.branchName;
    data["salary"] = this.salary;
    data["companyRoleId"] = this.companyRoleId;
    data["companyRoleName"] = this.companyRoleName;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface ICompanyStaffDto {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  isEnabled?: boolean;
  branchId?: string | undefined;
  branchName?: string | undefined;
  salary?: number;
  companyRoleId?: string | undefined;
  companyRoleName?: string | undefined;
  createdDate?: string;
}

export class GetCompanyStaffsForPayRollResponseModel implements IGetCompanyStaffsForPayRollResponseModel {
  data?: CompanyStaffDto[] | undefined;
  count?: number;

  constructor(data?: IGetCompanyStaffsForPayRollResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(CompanyStaffDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetCompanyStaffsForPayRollResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyStaffsForPayRollResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetCompanyStaffsForPayRollResponseModel {
  data?: CompanyStaffDto[] | undefined;
  count?: number;
}

export class GetCompanyStaffByIdResponseModel implements IGetCompanyStaffByIdResponseModel {
  data?: CompanyStaffDto | undefined;

  constructor(data?: IGetCompanyStaffByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyStaffDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetCompanyStaffByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyStaffByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetCompanyStaffByIdResponseModel {
  data?: CompanyStaffDto | undefined;
}

export class GetCompanyStaffsDropDownResponseModel implements IGetCompanyStaffsDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;

  constructor(data?: IGetCompanyStaffsDropDownResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(DropDownDtoOfString.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetCompanyStaffsDropDownResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyStaffsDropDownResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetCompanyStaffsDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;
}

export class CreateCompanyStaffResponseModel implements ICreateCompanyStaffResponseModel {
  data?: CompanyStaffDto | undefined;

  constructor(data?: ICreateCompanyStaffResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyStaffDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateCompanyStaffResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCompanyStaffResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateCompanyStaffResponseModel {
  data?: CompanyStaffDto | undefined;
}

export class CreateCompanyStaffRequestModel implements ICreateCompanyStaffRequestModel {
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  image?: string | undefined;
  companyRoleId?: string | undefined;
  branchId?: string | undefined;
  salary?: number;

  constructor(data?: ICreateCompanyStaffRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.image = _data["image"];
      this.companyRoleId = _data["companyRoleId"];
      this.branchId = _data["branchId"];
      this.salary = _data["salary"];
    }
  }

  static fromJS(data: any): CreateCompanyStaffRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCompanyStaffRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["image"] = this.image;
    data["companyRoleId"] = this.companyRoleId;
    data["branchId"] = this.branchId;
    data["salary"] = this.salary;
    return data;
  }
}

export interface ICreateCompanyStaffRequestModel {
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  image?: string | undefined;
  companyRoleId?: string | undefined;
  branchId?: string | undefined;
  salary?: number;
}

export class UpdateCompanyStaffProfileResponseModel implements IUpdateCompanyStaffProfileResponseModel {
  data?: CompanyStaffDto | undefined;
  message?: string | undefined;

  constructor(data?: IUpdateCompanyStaffProfileResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyStaffDto.fromJS(_data["data"]) : undefined as any;
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): UpdateCompanyStaffProfileResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyStaffProfileResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    data["message"] = this.message;
    return data;
  }
}

export interface IUpdateCompanyStaffProfileResponseModel {
  data?: CompanyStaffDto | undefined;
  message?: string | undefined;
}

export class UpdateCompanyStaffProfileRequestModel implements IUpdateCompanyStaffProfileRequestModel {
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;

  constructor(data?: IUpdateCompanyStaffProfileRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.image = _data["image"];
      this.isAllowEmail = _data["isAllowEmail"];
      this.isAllowNotification = _data["isAllowNotification"];
    }
  }

  static fromJS(data: any): UpdateCompanyStaffProfileRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyStaffProfileRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["image"] = this.image;
    data["isAllowEmail"] = this.isAllowEmail;
    data["isAllowNotification"] = this.isAllowNotification;
    return data;
  }
}

export interface IUpdateCompanyStaffProfileRequestModel {
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;
}

export class GetCompanyStaffProfileResponseModel implements IGetCompanyStaffProfileResponseModel {
  data?: CompanyStaffProfileDto | undefined;

  constructor(data?: IGetCompanyStaffProfileResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyStaffProfileDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetCompanyStaffProfileResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanyStaffProfileResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetCompanyStaffProfileResponseModel {
  data?: CompanyStaffProfileDto | undefined;
}

export class CompanyStaffProfileDto implements ICompanyStaffProfileDto {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  salary?: number;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;

  constructor(data?: ICompanyStaffProfileDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.image = _data["image"];
      this.salary = _data["salary"];
      this.isAllowEmail = _data["isAllowEmail"];
      this.isAllowNotification = _data["isAllowNotification"];
    }
  }

  static fromJS(data: any): CompanyStaffProfileDto {
    data = typeof data === 'object' ? data : {};
    let result = new CompanyStaffProfileDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["image"] = this.image;
    data["salary"] = this.salary;
    data["isAllowEmail"] = this.isAllowEmail;
    data["isAllowNotification"] = this.isAllowNotification;
    return data;
  }
}

export interface ICompanyStaffProfileDto {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  salary?: number;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;
}

export class UpdateCompanyStaffResponseModel implements IUpdateCompanyStaffResponseModel {
  data?: CompanyStaffDto | undefined;

  constructor(data?: IUpdateCompanyStaffResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanyStaffDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): UpdateCompanyStaffResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyStaffResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IUpdateCompanyStaffResponseModel {
  data?: CompanyStaffDto | undefined;
}

export class UpdateCompanyStaffRequestModel implements IUpdateCompanyStaffRequestModel {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  companyRoleId?: string | undefined;
  isEnabled?: boolean;
  branchId?: string | undefined;
  salary?: number;

  constructor(data?: IUpdateCompanyStaffRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.image = _data["image"];
      this.companyRoleId = _data["companyRoleId"];
      this.isEnabled = _data["isEnabled"];
      this.branchId = _data["branchId"];
      this.salary = _data["salary"];
    }
  }

  static fromJS(data: any): UpdateCompanyStaffRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyStaffRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["image"] = this.image;
    data["companyRoleId"] = this.companyRoleId;
    data["isEnabled"] = this.isEnabled;
    data["branchId"] = this.branchId;
    data["salary"] = this.salary;
    return data;
  }
}

export interface IUpdateCompanyStaffRequestModel {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  companyRoleId?: string | undefined;
  isEnabled?: boolean;
  branchId?: string | undefined;
  salary?: number;
}

export class DeleteCompanyStaffResponseModel implements IDeleteCompanyStaffResponseModel {
  success?: boolean;

  constructor(data?: IDeleteCompanyStaffResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data["success"];
    }
  }

  static fromJS(data: any): DeleteCompanyStaffResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteCompanyStaffResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["success"] = this.success;
    return data;
  }
}

export interface IDeleteCompanyStaffResponseModel {
  success?: boolean;
}

export class CreateCompanySubscriptionRequestResponseModel implements ICreateCompanySubscriptionRequestResponseModel {
  data?: CompanySubscriptionRequestDto | undefined;
  message?: string | undefined;

  constructor(data?: ICreateCompanySubscriptionRequestResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanySubscriptionRequestDto.fromJS(_data["data"]) : undefined as any;
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): CreateCompanySubscriptionRequestResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCompanySubscriptionRequestResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    data["message"] = this.message;
    return data;
  }
}

export interface ICreateCompanySubscriptionRequestResponseModel {
  data?: CompanySubscriptionRequestDto | undefined;
  message?: string | undefined;
}

export class CompanySubscriptionRequestDto implements ICompanySubscriptionRequestDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  companyEmail?: string | undefined;
  subscriptionId?: string | undefined;
  subscriptionPlanName?: string | undefined;
  amount?: number;
  status?: RequestStatus;
  statusName?: string | undefined;
  invoiceUrl?: string | undefined;
  approvedByUserId?: string | undefined;
  approvedByUserName?: string | undefined;
  approvedDate?: string | undefined;
  rejectedByUserId?: string | undefined;
  rejectedByUserName?: string | undefined;
  rejectedDate?: string | undefined;
  adminNotes?: string | undefined;
  createdDate?: string;

  constructor(data?: ICompanySubscriptionRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyId = _data["companyId"];
      this.companyName = _data["companyName"];
      this.companyEmail = _data["companyEmail"];
      this.subscriptionId = _data["subscriptionId"];
      this.subscriptionPlanName = _data["subscriptionPlanName"];
      this.amount = _data["amount"];
      this.status = _data["status"];
      this.statusName = _data["statusName"];
      this.invoiceUrl = _data["invoiceUrl"];
      this.approvedByUserId = _data["approvedByUserId"];
      this.approvedByUserName = _data["approvedByUserName"];
      this.approvedDate = _data["approvedDate"];
      this.rejectedByUserId = _data["rejectedByUserId"];
      this.rejectedByUserName = _data["rejectedByUserName"];
      this.rejectedDate = _data["rejectedDate"];
      this.adminNotes = _data["adminNotes"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): CompanySubscriptionRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new CompanySubscriptionRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["companyId"] = this.companyId;
    data["companyName"] = this.companyName;
    data["companyEmail"] = this.companyEmail;
    data["subscriptionId"] = this.subscriptionId;
    data["subscriptionPlanName"] = this.subscriptionPlanName;
    data["amount"] = this.amount;
    data["status"] = this.status;
    data["statusName"] = this.statusName;
    data["invoiceUrl"] = this.invoiceUrl;
    data["approvedByUserId"] = this.approvedByUserId;
    data["approvedByUserName"] = this.approvedByUserName;
    data["approvedDate"] = this.approvedDate;
    data["rejectedByUserId"] = this.rejectedByUserId;
    data["rejectedByUserName"] = this.rejectedByUserName;
    data["rejectedDate"] = this.rejectedDate;
    data["adminNotes"] = this.adminNotes;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface ICompanySubscriptionRequestDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  companyEmail?: string | undefined;
  subscriptionId?: string | undefined;
  subscriptionPlanName?: string | undefined;
  amount?: number;
  status?: RequestStatus;
  statusName?: string | undefined;
  invoiceUrl?: string | undefined;
  approvedByUserId?: string | undefined;
  approvedByUserName?: string | undefined;
  approvedDate?: string | undefined;
  rejectedByUserId?: string | undefined;
  rejectedByUserName?: string | undefined;
  rejectedDate?: string | undefined;
  adminNotes?: string | undefined;
  createdDate?: string;
}

export class CreateCompanySubscriptionRequestModel implements ICreateCompanySubscriptionRequestModel {
  subscriptionId?: string | undefined;

  constructor(data?: ICreateCompanySubscriptionRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.subscriptionId = _data["subscriptionId"];
    }
  }

  static fromJS(data: any): CreateCompanySubscriptionRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCompanySubscriptionRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["subscriptionId"] = this.subscriptionId;
    return data;
  }
}

export interface ICreateCompanySubscriptionRequestModel {
  subscriptionId?: string | undefined;
}

export class GetCompanySubscriptionRequestsResponseModel implements IGetCompanySubscriptionRequestsResponseModel {
  data?: CompanySubscriptionRequestDto[] | undefined;
  count?: number;

  constructor(data?: IGetCompanySubscriptionRequestsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(CompanySubscriptionRequestDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetCompanySubscriptionRequestsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanySubscriptionRequestsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetCompanySubscriptionRequestsResponseModel {
  data?: CompanySubscriptionRequestDto[] | undefined;
  count?: number;
}

export class GetCompanySubscriptionRequestByIdResponseModel implements IGetCompanySubscriptionRequestByIdResponseModel {
  data?: CompanySubscriptionRequestDto | undefined;

  constructor(data?: IGetCompanySubscriptionRequestByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanySubscriptionRequestDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetCompanySubscriptionRequestByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetCompanySubscriptionRequestByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetCompanySubscriptionRequestByIdResponseModel {
  data?: CompanySubscriptionRequestDto | undefined;
}

export class ApproveCompanySubscriptionRequestResponseModel implements IApproveCompanySubscriptionRequestResponseModel {
  data?: CompanySubscriptionRequestDto | undefined;
  paymentData?: PaymentDto | undefined;
  message?: string | undefined;

  constructor(data?: IApproveCompanySubscriptionRequestResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanySubscriptionRequestDto.fromJS(_data["data"]) : undefined as any;
      this.paymentData = _data["paymentData"] ? PaymentDto.fromJS(_data["paymentData"]) : undefined as any;
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): ApproveCompanySubscriptionRequestResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new ApproveCompanySubscriptionRequestResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    data["paymentData"] = this.paymentData ? this.paymentData.toJSON() : undefined as any;
    data["message"] = this.message;
    return data;
  }
}

export interface IApproveCompanySubscriptionRequestResponseModel {
  data?: CompanySubscriptionRequestDto | undefined;
  paymentData?: PaymentDto | undefined;
  message?: string | undefined;
}

export class PaymentDto implements IPaymentDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  companyEmail?: string | undefined;
  companySubscriptionRequestId?: string | undefined;
  subscriptionId?: string | undefined;
  subscriptionPlanName?: string | undefined;
  amount?: number;
  subscriptionActivatedDate?: string | undefined;
  createdDate?: string;

  constructor(data?: IPaymentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyId = _data["companyId"];
      this.companyName = _data["companyName"];
      this.companyEmail = _data["companyEmail"];
      this.companySubscriptionRequestId = _data["companySubscriptionRequestId"];
      this.subscriptionId = _data["subscriptionId"];
      this.subscriptionPlanName = _data["subscriptionPlanName"];
      this.amount = _data["amount"];
      this.subscriptionActivatedDate = _data["subscriptionActivatedDate"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): PaymentDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaymentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["companyId"] = this.companyId;
    data["companyName"] = this.companyName;
    data["companyEmail"] = this.companyEmail;
    data["companySubscriptionRequestId"] = this.companySubscriptionRequestId;
    data["subscriptionId"] = this.subscriptionId;
    data["subscriptionPlanName"] = this.subscriptionPlanName;
    data["amount"] = this.amount;
    data["subscriptionActivatedDate"] = this.subscriptionActivatedDate;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface IPaymentDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  companyEmail?: string | undefined;
  companySubscriptionRequestId?: string | undefined;
  subscriptionId?: string | undefined;
  subscriptionPlanName?: string | undefined;
  amount?: number;
  subscriptionActivatedDate?: string | undefined;
  createdDate?: string;
}

export class ApproveCompanySubscriptionRequestModel implements IApproveCompanySubscriptionRequestModel {
  id?: string | undefined;
  adminNotes?: string | undefined;
  invoiceUrl?: string | undefined;

  constructor(data?: IApproveCompanySubscriptionRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.adminNotes = _data["adminNotes"];
      this.invoiceUrl = _data["invoiceUrl"];
    }
  }

  static fromJS(data: any): ApproveCompanySubscriptionRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new ApproveCompanySubscriptionRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["adminNotes"] = this.adminNotes;
    data["invoiceUrl"] = this.invoiceUrl;
    return data;
  }
}

export interface IApproveCompanySubscriptionRequestModel {
  id?: string | undefined;
  adminNotes?: string | undefined;
  invoiceUrl?: string | undefined;
}

export class RejectCompanySubscriptionRequestResponseModel implements IRejectCompanySubscriptionRequestResponseModel {
  data?: CompanySubscriptionRequestDto | undefined;
  message?: string | undefined;

  constructor(data?: IRejectCompanySubscriptionRequestResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? CompanySubscriptionRequestDto.fromJS(_data["data"]) : undefined as any;
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): RejectCompanySubscriptionRequestResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new RejectCompanySubscriptionRequestResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    data["message"] = this.message;
    return data;
  }
}

export interface IRejectCompanySubscriptionRequestResponseModel {
  data?: CompanySubscriptionRequestDto | undefined;
  message?: string | undefined;
}

export class RejectCompanySubscriptionRequestModel implements IRejectCompanySubscriptionRequestModel {
  id?: string | undefined;
  adminNotes?: string | undefined;

  constructor(data?: IRejectCompanySubscriptionRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.adminNotes = _data["adminNotes"];
    }
  }

  static fromJS(data: any): RejectCompanySubscriptionRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new RejectCompanySubscriptionRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["adminNotes"] = this.adminNotes;
    return data;
  }
}

export interface IRejectCompanySubscriptionRequestModel {
  id?: string | undefined;
  adminNotes?: string | undefined;
}

export class GetEmployeeDashboardResponseModel implements IGetEmployeeDashboardResponseModel {
  activeLoans?: number;
  loanPending?: number;
  amountPending?: number;

  constructor(data?: IGetEmployeeDashboardResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.activeLoans = _data["activeLoans"];
      this.loanPending = _data["loanPending"];
      this.amountPending = _data["amountPending"];
    }
  }

  static fromJS(data: any): GetEmployeeDashboardResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetEmployeeDashboardResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["activeLoans"] = this.activeLoans;
    data["loanPending"] = this.loanPending;
    data["amountPending"] = this.amountPending;
    return data;
  }
}

export interface IGetEmployeeDashboardResponseModel {
  activeLoans?: number;
  loanPending?: number;
  amountPending?: number;
}

export class GetLoanOffersResponseModel implements IGetLoanOffersResponseModel {
  data?: LoanOfferDto[] | undefined;
  count?: number;

  constructor(data?: IGetLoanOffersResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(LoanOfferDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetLoanOffersResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetLoanOffersResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetLoanOffersResponseModel {
  data?: LoanOfferDto[] | undefined;
  count?: number;
}

export class LoanOfferDto implements ILoanOfferDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  title?: string | undefined;
  interestRate?: number;
  loanMin?: number;
  loanMax?: number;
  durations?: number[] | undefined;
  description?: string | undefined;
  isActive?: boolean;
  loanRequestCount?: number;
  createdDate?: string;
  durationsString?: string | undefined;

  constructor(data?: ILoanOfferDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyId = _data["companyId"];
      this.companyName = _data["companyName"];
      this.title = _data["title"];
      this.interestRate = _data["interestRate"];
      this.loanMin = _data["loanMin"];
      this.loanMax = _data["loanMax"];
      if (Array.isArray(_data["durations"])) {
        this.durations = [] as any;
        for (let item of _data["durations"])
          this.durations!.push(item);
      }
      this.description = _data["description"];
      this.isActive = _data["isActive"];
      this.loanRequestCount = _data["loanRequestCount"];
      this.createdDate = _data["createdDate"];
      this.durationsString = _data["durationsString"];
    }
  }

  static fromJS(data: any): LoanOfferDto {
    data = typeof data === 'object' ? data : {};
    let result = new LoanOfferDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["companyId"] = this.companyId;
    data["companyName"] = this.companyName;
    data["title"] = this.title;
    data["interestRate"] = this.interestRate;
    data["loanMin"] = this.loanMin;
    data["loanMax"] = this.loanMax;
    if (Array.isArray(this.durations)) {
      data["durations"] = [];
      for (let item of this.durations)
        data["durations"].push(item);
    }
    data["description"] = this.description;
    data["isActive"] = this.isActive;
    data["loanRequestCount"] = this.loanRequestCount;
    data["createdDate"] = this.createdDate;
    data["durationsString"] = this.durationsString;
    return data;
  }
}

export interface ILoanOfferDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  title?: string | undefined;
  interestRate?: number;
  loanMin?: number;
  loanMax?: number;
  durations?: number[] | undefined;
  description?: string | undefined;
  isActive?: boolean;
  loanRequestCount?: number;
  createdDate?: string;
  durationsString?: string | undefined;
}

export class GetLoanOffersPublicResponseModel implements IGetLoanOffersPublicResponseModel {
  count?: number;
  data?: LoanOfferDto[] | undefined;

  constructor(data?: IGetLoanOffersPublicResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.count = _data["count"];
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(LoanOfferDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetLoanOffersPublicResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetLoanOffersPublicResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["count"] = this.count;
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetLoanOffersPublicResponseModel {
  count?: number;
  data?: LoanOfferDto[] | undefined;
}

export class GetLoanOfferByIdResponseModel implements IGetLoanOfferByIdResponseModel {
  data?: LoanOfferDto | undefined;

  constructor(data?: IGetLoanOfferByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? LoanOfferDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetLoanOfferByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetLoanOfferByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetLoanOfferByIdResponseModel {
  data?: LoanOfferDto | undefined;
}

export class GetLoanOffersDropDownResponseModel implements IGetLoanOffersDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;

  constructor(data?: IGetLoanOffersDropDownResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(DropDownDtoOfString.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetLoanOffersDropDownResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetLoanOffersDropDownResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetLoanOffersDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;
}

export class CreateLoanOfferResponseModel implements ICreateLoanOfferResponseModel {
  data?: LoanOfferDto | undefined;

  constructor(data?: ICreateLoanOfferResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? LoanOfferDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateLoanOfferResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateLoanOfferResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateLoanOfferResponseModel {
  data?: LoanOfferDto | undefined;
}

export class CreateLoanOfferRequestModel implements ICreateLoanOfferRequestModel {
  title?: string | undefined;
  interestRate?: number;
  loanMin?: number;
  loanMax?: number;
  durations?: number[] | undefined;
  description?: string | undefined;

  constructor(data?: ICreateLoanOfferRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
      this.interestRate = _data["interestRate"];
      this.loanMin = _data["loanMin"];
      this.loanMax = _data["loanMax"];
      if (Array.isArray(_data["durations"])) {
        this.durations = [] as any;
        for (let item of _data["durations"])
          this.durations!.push(item);
      }
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): CreateLoanOfferRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateLoanOfferRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["title"] = this.title;
    data["interestRate"] = this.interestRate;
    data["loanMin"] = this.loanMin;
    data["loanMax"] = this.loanMax;
    if (Array.isArray(this.durations)) {
      data["durations"] = [];
      for (let item of this.durations)
        data["durations"].push(item);
    }
    data["description"] = this.description;
    return data;
  }
}

export interface ICreateLoanOfferRequestModel {
  title?: string | undefined;
  interestRate?: number;
  loanMin?: number;
  loanMax?: number;
  durations?: number[] | undefined;
  description?: string | undefined;
}

export class UpdateLoanOfferResponseModel implements IUpdateLoanOfferResponseModel {
  data?: LoanOfferDto | undefined;

  constructor(data?: IUpdateLoanOfferResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? LoanOfferDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): UpdateLoanOfferResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateLoanOfferResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IUpdateLoanOfferResponseModel {
  data?: LoanOfferDto | undefined;
}

export class UpdateLoanOfferRequestModel implements IUpdateLoanOfferRequestModel {
  id?: string | undefined;
  title?: string | undefined;
  interestRate?: number;
  loanMin?: number;
  loanMax?: number;
  durations?: number[] | undefined;
  description?: string | undefined;
  isActive?: boolean;

  constructor(data?: IUpdateLoanOfferRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.title = _data["title"];
      this.interestRate = _data["interestRate"];
      this.loanMin = _data["loanMin"];
      this.loanMax = _data["loanMax"];
      if (Array.isArray(_data["durations"])) {
        this.durations = [] as any;
        for (let item of _data["durations"])
          this.durations!.push(item);
      }
      this.description = _data["description"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): UpdateLoanOfferRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateLoanOfferRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["title"] = this.title;
    data["interestRate"] = this.interestRate;
    data["loanMin"] = this.loanMin;
    data["loanMax"] = this.loanMax;
    if (Array.isArray(this.durations)) {
      data["durations"] = [];
      for (let item of this.durations)
        data["durations"].push(item);
    }
    data["description"] = this.description;
    data["isActive"] = this.isActive;
    return data;
  }
}

export interface IUpdateLoanOfferRequestModel {
  id?: string | undefined;
  title?: string | undefined;
  interestRate?: number;
  loanMin?: number;
  loanMax?: number;
  durations?: number[] | undefined;
  description?: string | undefined;
  isActive?: boolean;
}

export class DeleteLoanOfferResponseModel implements IDeleteLoanOfferResponseModel {
  success?: boolean;

  constructor(data?: IDeleteLoanOfferResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data["success"];
    }
  }

  static fromJS(data: any): DeleteLoanOfferResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteLoanOfferResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["success"] = this.success;
    return data;
  }
}

export interface IDeleteLoanOfferResponseModel {
  success?: boolean;
}

export class PayBackLoanResponseModel implements IPayBackLoanResponseModel {
  success?: boolean;
  message?: string | undefined;
  transactionId?: string | undefined;
  paidAmount?: number;
  paymentDate?: string;
  totalLoanAmount?: number;
  totalPending?: number;

  constructor(data?: IPayBackLoanResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data["success"];
      this.message = _data["message"];
      this.transactionId = _data["transactionId"];
      this.paidAmount = _data["paidAmount"];
      this.paymentDate = _data["paymentDate"];
      this.totalLoanAmount = _data["totalLoanAmount"];
      this.totalPending = _data["totalPending"];
    }
  }

  static fromJS(data: any): PayBackLoanResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new PayBackLoanResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["success"] = this.success;
    data["message"] = this.message;
    data["transactionId"] = this.transactionId;
    data["paidAmount"] = this.paidAmount;
    data["paymentDate"] = this.paymentDate;
    data["totalLoanAmount"] = this.totalLoanAmount;
    data["totalPending"] = this.totalPending;
    return data;
  }
}

export interface IPayBackLoanResponseModel {
  success?: boolean;
  message?: string | undefined;
  transactionId?: string | undefined;
  paidAmount?: number;
  paymentDate?: string;
  totalLoanAmount?: number;
  totalPending?: number;
}

export class PayBackLoanRequestModel implements IPayBackLoanRequestModel {
  loanPaymentScheduleId?: string | undefined;
  amount?: number;
  paymentProof?: string | undefined;

  constructor(data?: IPayBackLoanRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanPaymentScheduleId = _data["loanPaymentScheduleId"];
      this.amount = _data["amount"];
      this.paymentProof = _data["paymentProof"];
    }
  }

  static fromJS(data: any): PayBackLoanRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new PayBackLoanRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["loanPaymentScheduleId"] = this.loanPaymentScheduleId;
    data["amount"] = this.amount;
    data["paymentProof"] = this.paymentProof;
    return data;
  }
}

export interface IPayBackLoanRequestModel {
  loanPaymentScheduleId?: string | undefined;
  amount?: number;
  paymentProof?: string | undefined;
}

export class GetLoanPaymentSchedulesEmployeeResponseModel implements IGetLoanPaymentSchedulesEmployeeResponseModel {
  data?: LoanPaymentScheduleEmployeeDto[] | undefined;
  count?: number;

  constructor(data?: IGetLoanPaymentSchedulesEmployeeResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(LoanPaymentScheduleEmployeeDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetLoanPaymentSchedulesEmployeeResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetLoanPaymentSchedulesEmployeeResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetLoanPaymentSchedulesEmployeeResponseModel {
  data?: LoanPaymentScheduleEmployeeDto[] | undefined;
  count?: number;
}

export class LoanPaymentScheduleEmployeeDto implements ILoanPaymentScheduleEmployeeDto {
  id?: string | undefined;
  loanRequestTitle?: string | undefined;
  month?: number;
  year?: number;
  periodText?: string | undefined;
  amount?: number;
  isPayed?: boolean;
  paidDate?: string | undefined;

  constructor(data?: ILoanPaymentScheduleEmployeeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.loanRequestTitle = _data["loanRequestTitle"];
      this.month = _data["month"];
      this.year = _data["year"];
      this.periodText = _data["periodText"];
      this.amount = _data["amount"];
      this.isPayed = _data["isPayed"];
      this.paidDate = _data["paidDate"];
    }
  }

  static fromJS(data: any): LoanPaymentScheduleEmployeeDto {
    data = typeof data === 'object' ? data : {};
    let result = new LoanPaymentScheduleEmployeeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["loanRequestTitle"] = this.loanRequestTitle;
    data["month"] = this.month;
    data["year"] = this.year;
    data["periodText"] = this.periodText;
    data["amount"] = this.amount;
    data["isPayed"] = this.isPayed;
    data["paidDate"] = this.paidDate;
    return data;
  }
}

export interface ILoanPaymentScheduleEmployeeDto {
  id?: string | undefined;
  loanRequestTitle?: string | undefined;
  month?: number;
  year?: number;
  periodText?: string | undefined;
  amount?: number;
  isPayed?: boolean;
  paidDate?: string | undefined;
}

export class GetLoanPaymentSchedulesResponseModel implements IGetLoanPaymentSchedulesResponseModel {
  data?: LoanPaymentScheduleDto[] | undefined;
  count?: number;

  constructor(data?: IGetLoanPaymentSchedulesResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(LoanPaymentScheduleDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetLoanPaymentSchedulesResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetLoanPaymentSchedulesResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetLoanPaymentSchedulesResponseModel {
  data?: LoanPaymentScheduleDto[] | undefined;
  count?: number;
}

export class LoanPaymentScheduleDto implements ILoanPaymentScheduleDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  loanRequestId?: string | undefined;
  loanRequestTitle?: string | undefined;
  companyStaffId?: string | undefined;
  companyStaffName?: string | undefined;
  companyStaffEmail?: string | undefined;
  month?: number;
  year?: number;
  periodText?: string | undefined;
  amount?: number;
  isPayed?: boolean;
  paidDate?: string | undefined;
  createdDate?: string;

  constructor(data?: ILoanPaymentScheduleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyId = _data["companyId"];
      this.companyName = _data["companyName"];
      this.loanRequestId = _data["loanRequestId"];
      this.loanRequestTitle = _data["loanRequestTitle"];
      this.companyStaffId = _data["companyStaffId"];
      this.companyStaffName = _data["companyStaffName"];
      this.companyStaffEmail = _data["companyStaffEmail"];
      this.month = _data["month"];
      this.year = _data["year"];
      this.periodText = _data["periodText"];
      this.amount = _data["amount"];
      this.isPayed = _data["isPayed"];
      this.paidDate = _data["paidDate"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): LoanPaymentScheduleDto {
    data = typeof data === 'object' ? data : {};
    let result = new LoanPaymentScheduleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["companyId"] = this.companyId;
    data["companyName"] = this.companyName;
    data["loanRequestId"] = this.loanRequestId;
    data["loanRequestTitle"] = this.loanRequestTitle;
    data["companyStaffId"] = this.companyStaffId;
    data["companyStaffName"] = this.companyStaffName;
    data["companyStaffEmail"] = this.companyStaffEmail;
    data["month"] = this.month;
    data["year"] = this.year;
    data["periodText"] = this.periodText;
    data["amount"] = this.amount;
    data["isPayed"] = this.isPayed;
    data["paidDate"] = this.paidDate;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface ILoanPaymentScheduleDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  loanRequestId?: string | undefined;
  loanRequestTitle?: string | undefined;
  companyStaffId?: string | undefined;
  companyStaffName?: string | undefined;
  companyStaffEmail?: string | undefined;
  month?: number;
  year?: number;
  periodText?: string | undefined;
  amount?: number;
  isPayed?: boolean;
  paidDate?: string | undefined;
  createdDate?: string;
}

export class GetLoanPaymentScheduleByIdResponseModel implements IGetLoanPaymentScheduleByIdResponseModel {
  data?: LoanPaymentScheduleDto | undefined;

  constructor(data?: IGetLoanPaymentScheduleByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? LoanPaymentScheduleDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetLoanPaymentScheduleByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetLoanPaymentScheduleByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetLoanPaymentScheduleByIdResponseModel {
  data?: LoanPaymentScheduleDto | undefined;
}

export class GetEmployeeLoanRequestsResponseModel implements IGetEmployeeLoanRequestsResponseModel {
  data?: LoanRequestEmployeeDto[] | undefined;
  count?: number;

  constructor(data?: IGetEmployeeLoanRequestsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(LoanRequestEmployeeDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetEmployeeLoanRequestsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetEmployeeLoanRequestsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetEmployeeLoanRequestsResponseModel {
  data?: LoanRequestEmployeeDto[] | undefined;
  count?: number;
}

export class LoanRequestEmployeeDto implements ILoanRequestEmployeeDto {
  id?: string | undefined;
  loanOfferTitle?: string | undefined;
  status?: LoanRequestStatus;
  totalPaid?: number;
  totalPending?: number;
  totalPaymentSchedulePending?: number;
  title?: string | undefined;
  amount?: number;
  duration?: number;
  interestRate?: number;
  totalPayback?: number;
  monthlyPayment?: number;

  constructor(data?: ILoanRequestEmployeeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.loanOfferTitle = _data["loanOfferTitle"];
      this.status = _data["status"];
      this.totalPaid = _data["totalPaid"];
      this.totalPending = _data["totalPending"];
      this.totalPaymentSchedulePending = _data["totalPaymentSchedulePending"];
      this.title = _data["title"];
      this.amount = _data["amount"];
      this.duration = _data["duration"];
      this.interestRate = _data["interestRate"];
      this.totalPayback = _data["totalPayback"];
      this.monthlyPayment = _data["monthlyPayment"];
    }
  }

  static fromJS(data: any): LoanRequestEmployeeDto {
    data = typeof data === 'object' ? data : {};
    let result = new LoanRequestEmployeeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["loanOfferTitle"] = this.loanOfferTitle;
    data["status"] = this.status;
    data["totalPaid"] = this.totalPaid;
    data["totalPending"] = this.totalPending;
    data["totalPaymentSchedulePending"] = this.totalPaymentSchedulePending;
    data["title"] = this.title;
    data["amount"] = this.amount;
    data["duration"] = this.duration;
    data["interestRate"] = this.interestRate;
    data["totalPayback"] = this.totalPayback;
    data["monthlyPayment"] = this.monthlyPayment;
    return data;
  }
}

export interface ILoanRequestEmployeeDto {
  id?: string | undefined;
  loanOfferTitle?: string | undefined;
  status?: LoanRequestStatus;
  totalPaid?: number;
  totalPending?: number;
  totalPaymentSchedulePending?: number;
  title?: string | undefined;
  amount?: number;
  duration?: number;
  interestRate?: number;
  totalPayback?: number;
  monthlyPayment?: number;
}

export enum LoanRequestStatus {
  Pending = 1,
  Approved = 2,
  Rejected = 3,
  Paid = 4,
}

export enum LoanRequestType {
  LoanOffer = 1,
  AdvanceSalary = 2,
}

export class GetLoanRequestsResponseModel implements IGetLoanRequestsResponseModel {
  data?: LoanRequestDto[] | undefined;
  count?: number;

  constructor(data?: IGetLoanRequestsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(LoanRequestDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetLoanRequestsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetLoanRequestsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetLoanRequestsResponseModel {
  data?: LoanRequestDto[] | undefined;
  count?: number;
}

export class LoanRequestDto implements ILoanRequestDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  companyStaffId?: string | undefined;
  companyStaffName?: string | undefined;
  companyStaffEmail?: string | undefined;
  loanOfferId?: string | undefined;
  loanOfferTitle?: string | undefined;
  title?: string | undefined;
  amount?: number;
  duration?: number;
  interestRate?: number;
  totalPayback?: number;
  monthlyPayment?: number;
  purpose?: string | undefined;
  documentPath?: string | undefined;
  status?: LoanRequestStatus;
  statusText?: string | undefined;
  approvedByUserId?: string | undefined;
  approvedByName?: string | undefined;
  approvedDate?: string | undefined;
  rejectedByUserId?: string | undefined;
  rejectedByName?: string | undefined;
  rejectedDate?: string | undefined;
  rejectionReason?: string | undefined;
  createdDate?: string;
  type?: LoanRequestType;

  constructor(data?: ILoanRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyId = _data["companyId"];
      this.companyName = _data["companyName"];
      this.companyStaffId = _data["companyStaffId"];
      this.companyStaffName = _data["companyStaffName"];
      this.companyStaffEmail = _data["companyStaffEmail"];
      this.loanOfferId = _data["loanOfferId"];
      this.loanOfferTitle = _data["loanOfferTitle"];
      this.title = _data["title"];
      this.amount = _data["amount"];
      this.duration = _data["duration"];
      this.interestRate = _data["interestRate"];
      this.totalPayback = _data["totalPayback"];
      this.monthlyPayment = _data["monthlyPayment"];
      this.purpose = _data["purpose"];
      this.documentPath = _data["documentPath"];
      this.status = _data["status"];
      this.statusText = _data["statusText"];
      this.approvedByUserId = _data["approvedByUserId"];
      this.approvedByName = _data["approvedByName"];
      this.approvedDate = _data["approvedDate"];
      this.rejectedByUserId = _data["rejectedByUserId"];
      this.rejectedByName = _data["rejectedByName"];
      this.rejectedDate = _data["rejectedDate"];
      this.rejectionReason = _data["rejectionReason"];
      this.createdDate = _data["createdDate"];
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): LoanRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new LoanRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["companyId"] = this.companyId;
    data["companyName"] = this.companyName;
    data["companyStaffId"] = this.companyStaffId;
    data["companyStaffName"] = this.companyStaffName;
    data["companyStaffEmail"] = this.companyStaffEmail;
    data["loanOfferId"] = this.loanOfferId;
    data["loanOfferTitle"] = this.loanOfferTitle;
    data["title"] = this.title;
    data["amount"] = this.amount;
    data["duration"] = this.duration;
    data["interestRate"] = this.interestRate;
    data["totalPayback"] = this.totalPayback;
    data["monthlyPayment"] = this.monthlyPayment;
    data["purpose"] = this.purpose;
    data["documentPath"] = this.documentPath;
    data["status"] = this.status;
    data["statusText"] = this.statusText;
    data["approvedByUserId"] = this.approvedByUserId;
    data["approvedByName"] = this.approvedByName;
    data["approvedDate"] = this.approvedDate;
    data["rejectedByUserId"] = this.rejectedByUserId;
    data["rejectedByName"] = this.rejectedByName;
    data["rejectedDate"] = this.rejectedDate;
    data["rejectionReason"] = this.rejectionReason;
    data["createdDate"] = this.createdDate;
    data["type"] = this.type;
    return data;
  }
}

export interface ILoanRequestDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  companyStaffId?: string | undefined;
  companyStaffName?: string | undefined;
  companyStaffEmail?: string | undefined;
  loanOfferId?: string | undefined;
  loanOfferTitle?: string | undefined;
  title?: string | undefined;
  amount?: number;
  duration?: number;
  interestRate?: number;
  totalPayback?: number;
  monthlyPayment?: number;
  purpose?: string | undefined;
  documentPath?: string | undefined;
  status?: LoanRequestStatus;
  statusText?: string | undefined;
  approvedByUserId?: string | undefined;
  approvedByName?: string | undefined;
  approvedDate?: string | undefined;
  rejectedByUserId?: string | undefined;
  rejectedByName?: string | undefined;
  rejectedDate?: string | undefined;
  rejectionReason?: string | undefined;
  createdDate?: string;
  type?: LoanRequestType;
}

export class GetLoanRequestByIdResponseModel implements IGetLoanRequestByIdResponseModel {
  data?: LoanRequestDto | undefined;

  constructor(data?: IGetLoanRequestByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? LoanRequestDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetLoanRequestByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetLoanRequestByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetLoanRequestByIdResponseModel {
  data?: LoanRequestDto | undefined;
}

export class CreateLoanRequestResponseModel implements ICreateLoanRequestResponseModel {
  data?: LoanRequestDto | undefined;

  constructor(data?: ICreateLoanRequestResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? LoanRequestDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateLoanRequestResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateLoanRequestResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateLoanRequestResponseModel {
  data?: LoanRequestDto | undefined;
}

export class CreateLoanRequestRequestModel implements ICreateLoanRequestRequestModel {
  loanOfferId?: string | undefined;
  title?: string | undefined;
  amount?: number;
  duration?: number;
  interestRate?: number;
  purpose?: string | undefined;
  document?: string | undefined;
  type?: LoanRequestType;

  constructor(data?: ICreateLoanRequestRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanOfferId = _data["loanOfferId"];
      this.title = _data["title"];
      this.amount = _data["amount"];
      this.duration = _data["duration"];
      this.interestRate = _data["interestRate"];
      this.purpose = _data["purpose"];
      this.document = _data["document"];
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): CreateLoanRequestRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateLoanRequestRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["loanOfferId"] = this.loanOfferId;
    data["title"] = this.title;
    data["amount"] = this.amount;
    data["duration"] = this.duration;
    data["interestRate"] = this.interestRate;
    data["purpose"] = this.purpose;
    data["document"] = this.document;
    data["type"] = this.type;
    return data;
  }
}

export interface ICreateLoanRequestRequestModel {
  loanOfferId?: string | undefined;
  title?: string | undefined;
  amount?: number;
  duration?: number;
  interestRate?: number;
  purpose?: string | undefined;
  document?: string | undefined;
  type?: LoanRequestType;
}

export class ApproveLoanRequestResponseModel implements IApproveLoanRequestResponseModel {
  data?: LoanRequestDto | undefined;

  constructor(data?: IApproveLoanRequestResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? LoanRequestDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): ApproveLoanRequestResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new ApproveLoanRequestResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IApproveLoanRequestResponseModel {
  data?: LoanRequestDto | undefined;
}

export class RejectLoanRequestResponseModel implements IRejectLoanRequestResponseModel {
  data?: LoanRequestDto | undefined;

  constructor(data?: IRejectLoanRequestResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? LoanRequestDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): RejectLoanRequestResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new RejectLoanRequestResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IRejectLoanRequestResponseModel {
  data?: LoanRequestDto | undefined;
}

export class RejectLoanRequestRequestModel implements IRejectLoanRequestRequestModel {
  id?: string | undefined;
  rejectionReason?: string | undefined;

  constructor(data?: IRejectLoanRequestRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.rejectionReason = _data["rejectionReason"];
    }
  }

  static fromJS(data: any): RejectLoanRequestRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new RejectLoanRequestRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["rejectionReason"] = this.rejectionReason;
    return data;
  }
}

export interface IRejectLoanRequestRequestModel {
  id?: string | undefined;
  rejectionReason?: string | undefined;
}

export class GetNotificationsResponseModel implements IGetNotificationsResponseModel {
  data?: NotificationDto[] | undefined;
  count?: number;

  constructor(data?: IGetNotificationsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(NotificationDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetNotificationsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetNotificationsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetNotificationsResponseModel {
  data?: NotificationDto[] | undefined;
  count?: number;
}

export class NotificationDto implements INotificationDto {
  id?: string | undefined;
  message?: string | undefined;
  data?: string | undefined;
  type?: NotificationType;
  isRead?: boolean;
  createdDate?: string;

  constructor(data?: INotificationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.message = _data["message"];
      this.data = _data["data"];
      this.type = _data["type"];
      this.isRead = _data["isRead"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): NotificationDto {
    data = typeof data === 'object' ? data : {};
    let result = new NotificationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["message"] = this.message;
    data["data"] = this.data;
    data["type"] = this.type;
    data["isRead"] = this.isRead;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface INotificationDto {
  id?: string | undefined;
  message?: string | undefined;
  data?: string | undefined;
  type?: NotificationType;
  isRead?: boolean;
  createdDate?: string;
}

export enum NotificationType {
  CompanyRegistered = 0,
  SubscriptionRequestCreated = 1,
  SubscriptionRequestApproved = 2,
  SubscriptionRequestRejected = 3,
  PayrollApproved = 4,
  PayrollRejected = 5,
  LoanRequestCreated = 6,
  LoanRequestApproved = 7,
  LoanPaymentReceived = 8,
}

export class GetUnReadNotificationCountResponseModel implements IGetUnReadNotificationCountResponseModel {
  count?: number;

  constructor(data?: IGetUnReadNotificationCountResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetUnReadNotificationCountResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetUnReadNotificationCountResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["count"] = this.count;
    return data;
  }
}

export interface IGetUnReadNotificationCountResponseModel {
  count?: number;
}

export class ReadNotificationResponseModel implements IReadNotificationResponseModel {

  constructor(data?: IReadNotificationResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): ReadNotificationResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new ReadNotificationResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IReadNotificationResponseModel {
}

export class ReadAllUnReadNotificationResponseModel implements IReadAllUnReadNotificationResponseModel {

  constructor(data?: IReadAllUnReadNotificationResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): ReadAllUnReadNotificationResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new ReadAllUnReadNotificationResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IReadAllUnReadNotificationResponseModel {
}

export class CreateNotificationDeviceResponseModel implements ICreateNotificationDeviceResponseModel {

  constructor(data?: ICreateNotificationDeviceResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): CreateNotificationDeviceResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateNotificationDeviceResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface ICreateNotificationDeviceResponseModel {
}

export class CreateNotificationDeviceRequestModel implements ICreateNotificationDeviceRequestModel {
  fcmToken?: string | undefined;
  deviceId?: string | undefined;
  deviceType?: DeviceType;

  constructor(data?: ICreateNotificationDeviceRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fcmToken = _data["fcmToken"];
      this.deviceId = _data["deviceId"];
      this.deviceType = _data["deviceType"];
    }
  }

  static fromJS(data: any): CreateNotificationDeviceRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateNotificationDeviceRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["fcmToken"] = this.fcmToken;
    data["deviceId"] = this.deviceId;
    data["deviceType"] = this.deviceType;
    return data;
  }
}

export interface ICreateNotificationDeviceRequestModel {
  fcmToken?: string | undefined;
  deviceId?: string | undefined;
  deviceType?: DeviceType;
}

export enum DeviceType {
  Android = 0,
  IOS = 1,
}

export class GetPaymentsResponseModel implements IGetPaymentsResponseModel {
  data?: PaymentDto[] | undefined;
  count?: number;

  constructor(data?: IGetPaymentsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(PaymentDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetPaymentsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetPaymentsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetPaymentsResponseModel {
  data?: PaymentDto[] | undefined;
  count?: number;
}

export class GetPaymentByIdResponseModel implements IGetPaymentByIdResponseModel {
  data?: PaymentDto | undefined;

  constructor(data?: IGetPaymentByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? PaymentDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetPaymentByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetPaymentByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetPaymentByIdResponseModel {
  data?: PaymentDto | undefined;
}

export class GetPayrollsResponseModel implements IGetPayrollsResponseModel {
  data?: PayrollDto[] | undefined;
  count?: number;

  constructor(data?: IGetPayrollsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(PayrollDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetPayrollsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetPayrollsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetPayrollsResponseModel {
  data?: PayrollDto[] | undefined;
  count?: number;
}

export class PayrollDto implements IPayrollDto {
  id?: string | undefined;
  companyId?: string | undefined;
  month?: number;
  year?: number;
  companyStaffId?: string | undefined;
  staffName?: string | undefined;
  staffEmail?: string | undefined;
  branchId?: string | undefined;
  branchName?: string | undefined;
  amount?: number;
  loanDeduction?: number;
  netAmount?: number;
  status?: PayrollStatus;
  approvedByUserId?: string | undefined;
  approvedDate?: string | undefined;
  approvalProof?: string | undefined;
  rejectionReason?: string | undefined;
  rejectedDate?: string | undefined;
  createdDate?: string;

  constructor(data?: IPayrollDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyId = _data["companyId"];
      this.month = _data["month"];
      this.year = _data["year"];
      this.companyStaffId = _data["companyStaffId"];
      this.staffName = _data["staffName"];
      this.staffEmail = _data["staffEmail"];
      this.branchId = _data["branchId"];
      this.branchName = _data["branchName"];
      this.amount = _data["amount"];
      this.loanDeduction = _data["loanDeduction"];
      this.netAmount = _data["netAmount"];
      this.status = _data["status"];
      this.approvedByUserId = _data["approvedByUserId"];
      this.approvedDate = _data["approvedDate"];
      this.approvalProof = _data["approvalProof"];
      this.rejectionReason = _data["rejectionReason"];
      this.rejectedDate = _data["rejectedDate"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): PayrollDto {
    data = typeof data === 'object' ? data : {};
    let result = new PayrollDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["companyId"] = this.companyId;
    data["month"] = this.month;
    data["year"] = this.year;
    data["companyStaffId"] = this.companyStaffId;
    data["staffName"] = this.staffName;
    data["staffEmail"] = this.staffEmail;
    data["branchId"] = this.branchId;
    data["branchName"] = this.branchName;
    data["amount"] = this.amount;
    data["loanDeduction"] = this.loanDeduction;
    data["netAmount"] = this.netAmount;
    data["status"] = this.status;
    data["approvedByUserId"] = this.approvedByUserId;
    data["approvedDate"] = this.approvedDate;
    data["approvalProof"] = this.approvalProof;
    data["rejectionReason"] = this.rejectionReason;
    data["rejectedDate"] = this.rejectedDate;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface IPayrollDto {
  id?: string | undefined;
  companyId?: string | undefined;
  month?: number;
  year?: number;
  companyStaffId?: string | undefined;
  staffName?: string | undefined;
  staffEmail?: string | undefined;
  branchId?: string | undefined;
  branchName?: string | undefined;
  amount?: number;
  loanDeduction?: number;
  netAmount?: number;
  status?: PayrollStatus;
  approvedByUserId?: string | undefined;
  approvedDate?: string | undefined;
  approvalProof?: string | undefined;
  rejectionReason?: string | undefined;
  rejectedDate?: string | undefined;
  createdDate?: string;
}

export enum PayrollStatus {
  Pending = 1,
  Approved = 2,
  Rejected = 3,
}

export class GetPayrollByIdResponseModel implements IGetPayrollByIdResponseModel {
  data?: PayrollDto | undefined;

  constructor(data?: IGetPayrollByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? PayrollDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetPayrollByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetPayrollByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetPayrollByIdResponseModel {
  data?: PayrollDto | undefined;
}

export class CreatePayrollResponseModel implements ICreatePayrollResponseModel {

  constructor(data?: ICreatePayrollResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): CreatePayrollResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreatePayrollResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface ICreatePayrollResponseModel {
}

export class CreatePayrollRequestModel implements ICreatePayrollRequestModel {
  month?: number;
  year?: number;

  constructor(data?: ICreatePayrollRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.month = _data["month"];
      this.year = _data["year"];
    }
  }

  static fromJS(data: any): CreatePayrollRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreatePayrollRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["month"] = this.month;
    data["year"] = this.year;
    return data;
  }
}

export interface ICreatePayrollRequestModel {
  month?: number;
  year?: number;
}

export class CreatePayrollSummaryResponseModel implements ICreatePayrollSummaryResponseModel {
  totalEmployees?: number;
  totalAmount?: number;
  totalLoanDeductions?: number;
  totalNetAmount?: number;
  staffs?: CompanyStaffDto[] | undefined;

  constructor(data?: ICreatePayrollSummaryResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalEmployees = _data["totalEmployees"];
      this.totalAmount = _data["totalAmount"];
      this.totalLoanDeductions = _data["totalLoanDeductions"];
      this.totalNetAmount = _data["totalNetAmount"];
      if (Array.isArray(_data["staffs"])) {
        this.staffs = [] as any;
        for (let item of _data["staffs"])
          this.staffs!.push(CompanyStaffDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CreatePayrollSummaryResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreatePayrollSummaryResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalEmployees"] = this.totalEmployees;
    data["totalAmount"] = this.totalAmount;
    data["totalLoanDeductions"] = this.totalLoanDeductions;
    data["totalNetAmount"] = this.totalNetAmount;
    if (Array.isArray(this.staffs)) {
      data["staffs"] = [];
      for (let item of this.staffs)
        data["staffs"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface ICreatePayrollSummaryResponseModel {
  totalEmployees?: number;
  totalAmount?: number;
  totalLoanDeductions?: number;
  totalNetAmount?: number;
  staffs?: CompanyStaffDto[] | undefined;
}

export class CreatePayrollSummaryRequestModel implements ICreatePayrollSummaryRequestModel {
  month?: number;
  year?: number;

  constructor(data?: ICreatePayrollSummaryRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.month = _data["month"];
      this.year = _data["year"];
    }
  }

  static fromJS(data: any): CreatePayrollSummaryRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreatePayrollSummaryRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["month"] = this.month;
    data["year"] = this.year;
    return data;
  }
}

export interface ICreatePayrollSummaryRequestModel {
  month?: number;
  year?: number;
}

export class ApprovePayrollResponseModel implements IApprovePayrollResponseModel {
  data?: PayrollDto | undefined;

  constructor(data?: IApprovePayrollResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? PayrollDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): ApprovePayrollResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new ApprovePayrollResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IApprovePayrollResponseModel {
  data?: PayrollDto | undefined;
}

export class ApprovePayrollRequestModel implements IApprovePayrollRequestModel {
  id?: string | undefined;
  approvalProof?: string | undefined;

  constructor(data?: IApprovePayrollRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.approvalProof = _data["approvalProof"];
    }
  }

  static fromJS(data: any): ApprovePayrollRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new ApprovePayrollRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["approvalProof"] = this.approvalProof;
    return data;
  }
}

export interface IApprovePayrollRequestModel {
  id?: string | undefined;
  approvalProof?: string | undefined;
}

export class RejectPayrollResponseModel implements IRejectPayrollResponseModel {
  data?: PayrollDto | undefined;

  constructor(data?: IRejectPayrollResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? PayrollDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): RejectPayrollResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new RejectPayrollResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IRejectPayrollResponseModel {
  data?: PayrollDto | undefined;
}

export class RejectPayrollRequestModel implements IRejectPayrollRequestModel {
  id?: string | undefined;
  rejectionReason?: string | undefined;

  constructor(data?: IRejectPayrollRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.rejectionReason = _data["rejectionReason"];
    }
  }

  static fromJS(data: any): RejectPayrollRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new RejectPayrollRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["rejectionReason"] = this.rejectionReason;
    return data;
  }
}

export interface IRejectPayrollRequestModel {
  id?: string | undefined;
  rejectionReason?: string | undefined;
}

export class DeletePayrollResponseModel implements IDeletePayrollResponseModel {
  success?: boolean;

  constructor(data?: IDeletePayrollResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data["success"];
    }
  }

  static fromJS(data: any): DeletePayrollResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new DeletePayrollResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["success"] = this.success;
    return data;
  }
}

export interface IDeletePayrollResponseModel {
  success?: boolean;
}

export class GetAllAvailablePermissionsResponseModel implements IGetAllAvailablePermissionsResponseModel {
  data?: PermissionCategoryDto | undefined;

  constructor(data?: IGetAllAvailablePermissionsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? PermissionCategoryDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetAllAvailablePermissionsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllAvailablePermissionsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetAllAvailablePermissionsResponseModel {
  data?: PermissionCategoryDto | undefined;
}

export class PermissionCategoryDto implements IPermissionCategoryDto {
  categories?: PermissionGroupDto[] | undefined;

  constructor(data?: IPermissionCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["categories"])) {
        this.categories = [] as any;
        for (let item of _data["categories"])
          this.categories!.push(PermissionGroupDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PermissionCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new PermissionCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.categories)) {
      data["categories"] = [];
      for (let item of this.categories)
        data["categories"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IPermissionCategoryDto {
  categories?: PermissionGroupDto[] | undefined;
}

export class PermissionGroupDto implements IPermissionGroupDto {
  name?: string | undefined;
  permissions?: string[] | undefined;
  groups?: PermissionGroupDto[] | undefined;

  constructor(data?: IPermissionGroupDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions!.push(item);
      }
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"])
          this.groups!.push(PermissionGroupDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PermissionGroupDto {
    data = typeof data === 'object' ? data : {};
    let result = new PermissionGroupDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item);
    }
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups)
        data["groups"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IPermissionGroupDto {
  name?: string | undefined;
  permissions?: string[] | undefined;
  groups?: PermissionGroupDto[] | undefined;
}

export class GetStaffAdminsResponseModel implements IGetStaffAdminsResponseModel {
  data?: StaffAdminDto[] | undefined;
  count?: number;

  constructor(data?: IGetStaffAdminsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(StaffAdminDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetStaffAdminsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetStaffAdminsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetStaffAdminsResponseModel {
  data?: StaffAdminDto[] | undefined;
  count?: number;
}

export class StaffAdminDto implements IStaffAdminDto {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  isEnabled?: boolean;
  adminRoleId?: string | undefined;
  adminRoleName?: string | undefined;
  createdDate?: string;

  constructor(data?: IStaffAdminDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.image = _data["image"];
      this.isEnabled = _data["isEnabled"];
      this.adminRoleId = _data["adminRoleId"];
      this.adminRoleName = _data["adminRoleName"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): StaffAdminDto {
    data = typeof data === 'object' ? data : {};
    let result = new StaffAdminDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["image"] = this.image;
    data["isEnabled"] = this.isEnabled;
    data["adminRoleId"] = this.adminRoleId;
    data["adminRoleName"] = this.adminRoleName;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface IStaffAdminDto {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  isEnabled?: boolean;
  adminRoleId?: string | undefined;
  adminRoleName?: string | undefined;
  createdDate?: string;
}

export class GetStaffAdminByIdResponseModel implements IGetStaffAdminByIdResponseModel {
  data?: StaffAdminDto | undefined;

  constructor(data?: IGetStaffAdminByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? StaffAdminDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetStaffAdminByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetStaffAdminByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetStaffAdminByIdResponseModel {
  data?: StaffAdminDto | undefined;
}

export class GetStaffAdminsDropDownResponseModel implements IGetStaffAdminsDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;

  constructor(data?: IGetStaffAdminsDropDownResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(DropDownDtoOfString.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetStaffAdminsDropDownResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetStaffAdminsDropDownResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetStaffAdminsDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;
}

export class CreateStaffAdminResponseModel implements ICreateStaffAdminResponseModel {
  data?: StaffAdminDto | undefined;

  constructor(data?: ICreateStaffAdminResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? StaffAdminDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateStaffAdminResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateStaffAdminResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateStaffAdminResponseModel {
  data?: StaffAdminDto | undefined;
}

export class CreateStaffAdminRequestModel implements ICreateStaffAdminRequestModel {
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  image?: string | undefined;
  adminRoleId?: string | undefined;

  constructor(data?: ICreateStaffAdminRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.image = _data["image"];
      this.adminRoleId = _data["adminRoleId"];
    }
  }

  static fromJS(data: any): CreateStaffAdminRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateStaffAdminRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["image"] = this.image;
    data["adminRoleId"] = this.adminRoleId;
    return data;
  }
}

export interface ICreateStaffAdminRequestModel {
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  image?: string | undefined;
  adminRoleId?: string | undefined;
}

export class UpdateStaffAdminProfileResponseModel implements IUpdateStaffAdminProfileResponseModel {
  data?: StaffAdminDto | undefined;
  message?: string | undefined;

  constructor(data?: IUpdateStaffAdminProfileResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? StaffAdminDto.fromJS(_data["data"]) : undefined as any;
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): UpdateStaffAdminProfileResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateStaffAdminProfileResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    data["message"] = this.message;
    return data;
  }
}

export interface IUpdateStaffAdminProfileResponseModel {
  data?: StaffAdminDto | undefined;
  message?: string | undefined;
}

export class UpdateStaffAdminProfileRequestModel implements IUpdateStaffAdminProfileRequestModel {
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;

  constructor(data?: IUpdateStaffAdminProfileRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.image = _data["image"];
      this.isAllowEmail = _data["isAllowEmail"];
      this.isAllowNotification = _data["isAllowNotification"];
    }
  }

  static fromJS(data: any): UpdateStaffAdminProfileRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateStaffAdminProfileRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["image"] = this.image;
    data["isAllowEmail"] = this.isAllowEmail;
    data["isAllowNotification"] = this.isAllowNotification;
    return data;
  }
}

export interface IUpdateStaffAdminProfileRequestModel {
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;
}

export class GetStaffAdminProfileResponseModel implements IGetStaffAdminProfileResponseModel {
  data?: StaffAdminProfileDto | undefined;

  constructor(data?: IGetStaffAdminProfileResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? StaffAdminProfileDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetStaffAdminProfileResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetStaffAdminProfileResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetStaffAdminProfileResponseModel {
  data?: StaffAdminProfileDto | undefined;
}

export class StaffAdminProfileDto implements IStaffAdminProfileDto {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;

  constructor(data?: IStaffAdminProfileDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.image = _data["image"];
      this.isAllowEmail = _data["isAllowEmail"];
      this.isAllowNotification = _data["isAllowNotification"];
    }
  }

  static fromJS(data: any): StaffAdminProfileDto {
    data = typeof data === 'object' ? data : {};
    let result = new StaffAdminProfileDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["image"] = this.image;
    data["isAllowEmail"] = this.isAllowEmail;
    data["isAllowNotification"] = this.isAllowNotification;
    return data;
  }
}

export interface IStaffAdminProfileDto {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;
}

export class UpdateStaffAdminResponseModel implements IUpdateStaffAdminResponseModel {
  data?: StaffAdminDto | undefined;

  constructor(data?: IUpdateStaffAdminResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? StaffAdminDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): UpdateStaffAdminResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateStaffAdminResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IUpdateStaffAdminResponseModel {
  data?: StaffAdminDto | undefined;
}

export class UpdateStaffAdminRequestModel implements IUpdateStaffAdminRequestModel {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  adminRoleId?: string | undefined;
  isEnabled?: boolean;

  constructor(data?: IUpdateStaffAdminRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.image = _data["image"];
      this.adminRoleId = _data["adminRoleId"];
      this.isEnabled = _data["isEnabled"];
    }
  }

  static fromJS(data: any): UpdateStaffAdminRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateStaffAdminRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["image"] = this.image;
    data["adminRoleId"] = this.adminRoleId;
    data["isEnabled"] = this.isEnabled;
    return data;
  }
}

export interface IUpdateStaffAdminRequestModel {
  id?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  image?: string | undefined;
  adminRoleId?: string | undefined;
  isEnabled?: boolean;
}

export class DeleteStaffAdminResponseModel implements IDeleteStaffAdminResponseModel {
  success?: boolean;

  constructor(data?: IDeleteStaffAdminResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data["success"];
    }
  }

  static fromJS(data: any): DeleteStaffAdminResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteStaffAdminResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["success"] = this.success;
    return data;
  }
}

export interface IDeleteStaffAdminResponseModel {
  success?: boolean;
}

export class GetSubscriptionsResponseModel implements IGetSubscriptionsResponseModel {
  data?: SubscriptionDto[] | undefined;
  count?: number;

  constructor(data?: IGetSubscriptionsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(SubscriptionDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetSubscriptionsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetSubscriptionsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetSubscriptionsResponseModel {
  data?: SubscriptionDto[] | undefined;
  count?: number;
}

export class SubscriptionDto implements ISubscriptionDto {
  id?: string | undefined;
  planName?: string | undefined;
  billingCycle?: BillingCycle;
  price?: number;
  maxUsersAllowed?: number;
  maxBranches?: number;
  features?: string | undefined;
  isActive?: boolean;
  createdDate?: string;

  constructor(data?: ISubscriptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.planName = _data["planName"];
      this.billingCycle = _data["billingCycle"];
      this.price = _data["price"];
      this.maxUsersAllowed = _data["maxUsersAllowed"];
      this.maxBranches = _data["maxBranches"];
      this.features = _data["features"];
      this.isActive = _data["isActive"];
      this.createdDate = _data["createdDate"];
    }
  }

  static fromJS(data: any): SubscriptionDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscriptionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["planName"] = this.planName;
    data["billingCycle"] = this.billingCycle;
    data["price"] = this.price;
    data["maxUsersAllowed"] = this.maxUsersAllowed;
    data["maxBranches"] = this.maxBranches;
    data["features"] = this.features;
    data["isActive"] = this.isActive;
    data["createdDate"] = this.createdDate;
    return data;
  }
}

export interface ISubscriptionDto {
  id?: string | undefined;
  planName?: string | undefined;
  billingCycle?: BillingCycle;
  price?: number;
  maxUsersAllowed?: number;
  maxBranches?: number;
  features?: string | undefined;
  isActive?: boolean;
  createdDate?: string;
}

export enum BillingCycle {
  Monthly = 1,
  Yearly = 2,
}

export class GetSubscriptionsDropDownResponseModel implements IGetSubscriptionsDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;

  constructor(data?: IGetSubscriptionsDropDownResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(DropDownDtoOfString.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetSubscriptionsDropDownResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetSubscriptionsDropDownResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetSubscriptionsDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;
}

export class GetActiveSubscriptionResponseModel implements IGetActiveSubscriptionResponseModel {
  data?: SubscriptionDto[] | undefined;

  constructor(data?: IGetActiveSubscriptionResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(SubscriptionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetActiveSubscriptionResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetActiveSubscriptionResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetActiveSubscriptionResponseModel {
  data?: SubscriptionDto[] | undefined;
}

export class GetSubscriptionByIdResponseModel implements IGetSubscriptionByIdResponseModel {
  data?: SubscriptionDto | undefined;

  constructor(data?: IGetSubscriptionByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? SubscriptionDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetSubscriptionByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetSubscriptionByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetSubscriptionByIdResponseModel {
  data?: SubscriptionDto | undefined;
}

export class CreateSubscriptionResponseModel implements ICreateSubscriptionResponseModel {
  data?: SubscriptionDto | undefined;

  constructor(data?: ICreateSubscriptionResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? SubscriptionDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateSubscriptionResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateSubscriptionResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateSubscriptionResponseModel {
  data?: SubscriptionDto | undefined;
}

export class CreateSubscriptionRequestModel implements ICreateSubscriptionRequestModel {
  planName?: string | undefined;
  billingCycle?: BillingCycle;
  price?: number;
  maxUsersAllowed?: number;
  maxBranches?: number;
  features?: string | undefined;
  isActive?: boolean;

  constructor(data?: ICreateSubscriptionRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.planName = _data["planName"];
      this.billingCycle = _data["billingCycle"];
      this.price = _data["price"];
      this.maxUsersAllowed = _data["maxUsersAllowed"];
      this.maxBranches = _data["maxBranches"];
      this.features = _data["features"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): CreateSubscriptionRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateSubscriptionRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["planName"] = this.planName;
    data["billingCycle"] = this.billingCycle;
    data["price"] = this.price;
    data["maxUsersAllowed"] = this.maxUsersAllowed;
    data["maxBranches"] = this.maxBranches;
    data["features"] = this.features;
    data["isActive"] = this.isActive;
    return data;
  }
}

export interface ICreateSubscriptionRequestModel {
  planName?: string | undefined;
  billingCycle?: BillingCycle;
  price?: number;
  maxUsersAllowed?: number;
  maxBranches?: number;
  features?: string | undefined;
  isActive?: boolean;
}

export class UpdateSubscriptionResponseModel implements IUpdateSubscriptionResponseModel {
  data?: SubscriptionDto | undefined;

  constructor(data?: IUpdateSubscriptionResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? SubscriptionDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): UpdateSubscriptionResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateSubscriptionResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IUpdateSubscriptionResponseModel {
  data?: SubscriptionDto | undefined;
}

export class UpdateSubscriptionRequestModel implements IUpdateSubscriptionRequestModel {
  id?: string | undefined;
  planName?: string | undefined;
  billingCycle?: BillingCycle;
  price?: number;
  maxUsersAllowed?: number;
  maxBranches?: number;
  features?: string | undefined;
  isActive?: boolean;

  constructor(data?: IUpdateSubscriptionRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.planName = _data["planName"];
      this.billingCycle = _data["billingCycle"];
      this.price = _data["price"];
      this.maxUsersAllowed = _data["maxUsersAllowed"];
      this.maxBranches = _data["maxBranches"];
      this.features = _data["features"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): UpdateSubscriptionRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateSubscriptionRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["planName"] = this.planName;
    data["billingCycle"] = this.billingCycle;
    data["price"] = this.price;
    data["maxUsersAllowed"] = this.maxUsersAllowed;
    data["maxBranches"] = this.maxBranches;
    data["features"] = this.features;
    data["isActive"] = this.isActive;
    return data;
  }
}

export interface IUpdateSubscriptionRequestModel {
  id?: string | undefined;
  planName?: string | undefined;
  billingCycle?: BillingCycle;
  price?: number;
  maxUsersAllowed?: number;
  maxBranches?: number;
  features?: string | undefined;
  isActive?: boolean;
}

export class DeleteSubscriptionResponseModel implements IDeleteSubscriptionResponseModel {
  success?: boolean;

  constructor(data?: IDeleteSubscriptionResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data["success"];
    }
  }

  static fromJS(data: any): DeleteSubscriptionResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteSubscriptionResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["success"] = this.success;
    return data;
  }
}

export interface IDeleteSubscriptionResponseModel {
  success?: boolean;
}

export class GetTempHoldsResponseModel implements IGetTempHoldsResponseModel {
  data?: CompanyStaffDto[] | undefined;
  count?: number;

  constructor(data?: IGetTempHoldsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(CompanyStaffDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetTempHoldsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetTempHoldsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetTempHoldsResponseModel {
  data?: CompanyStaffDto[] | undefined;
  count?: number;
}

export class GetTempHoldByIdResponseModel implements IGetTempHoldByIdResponseModel {
  data?: TempHoldDto | undefined;

  constructor(data?: IGetTempHoldByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? TempHoldDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetTempHoldByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetTempHoldByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetTempHoldByIdResponseModel {
  data?: TempHoldDto | undefined;
}

export class TempHoldDto implements ITempHoldDto {
  companyStaffId?: string | undefined;
  month?: number;
  year?: number;
  createdDate?: string;
  updatedDate?: string;

  constructor(data?: ITempHoldDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.companyStaffId = _data["companyStaffId"];
      this.month = _data["month"];
      this.year = _data["year"];
      this.createdDate = _data["createdDate"];
      this.updatedDate = _data["updatedDate"];
    }
  }

  static fromJS(data: any): TempHoldDto {
    data = typeof data === 'object' ? data : {};
    let result = new TempHoldDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["companyStaffId"] = this.companyStaffId;
    data["month"] = this.month;
    data["year"] = this.year;
    data["createdDate"] = this.createdDate;
    data["updatedDate"] = this.updatedDate;
    return data;
  }
}

export interface ITempHoldDto {
  companyStaffId?: string | undefined;
  month?: number;
  year?: number;
  createdDate?: string;
  updatedDate?: string;
}

export class CreateTempHoldResponseModel implements ICreateTempHoldResponseModel {
  data?: TempHoldDto | undefined;

  constructor(data?: ICreateTempHoldResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? TempHoldDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateTempHoldResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateTempHoldResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateTempHoldResponseModel {
  data?: TempHoldDto | undefined;
}

export class CreateTempHoldRequestModel implements ICreateTempHoldRequestModel {
  companyStaffId?: string | undefined;
  month?: number;
  year?: number;

  constructor(data?: ICreateTempHoldRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.companyStaffId = _data["companyStaffId"];
      this.month = _data["month"];
      this.year = _data["year"];
    }
  }

  static fromJS(data: any): CreateTempHoldRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateTempHoldRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["companyStaffId"] = this.companyStaffId;
    data["month"] = this.month;
    data["year"] = this.year;
    return data;
  }
}

export interface ICreateTempHoldRequestModel {
  companyStaffId?: string | undefined;
  month?: number;
  year?: number;
}

export class DeleteTempHoldResponseModel implements IDeleteTempHoldResponseModel {
  success?: boolean;

  constructor(data?: IDeleteTempHoldResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data["success"];
    }
  }

  static fromJS(data: any): DeleteTempHoldResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteTempHoldResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["success"] = this.success;
    return data;
  }
}

export interface IDeleteTempHoldResponseModel {
  success?: boolean;
}

export class SendTestNotificationResponseModel implements ISendTestNotificationResponseModel {

  constructor(data?: ISendTestNotificationResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): SendTestNotificationResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new SendTestNotificationResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface ISendTestNotificationResponseModel {
}

export class GetTransactionsEmployeeResponseModel implements IGetTransactionsEmployeeResponseModel {
  data?: TransactionEmployeeDto[] | undefined;
  count?: number;

  constructor(data?: IGetTransactionsEmployeeResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(TransactionEmployeeDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetTransactionsEmployeeResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetTransactionsEmployeeResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetTransactionsEmployeeResponseModel {
  data?: TransactionEmployeeDto[] | undefined;
  count?: number;
}

export class TransactionEmployeeDto implements ITransactionEmployeeDto {
  id?: string | undefined;
  type?: TransactionType;
  amount?: number;
  description?: string | undefined;
  descriptionFr?: string | undefined;
  reference?: string | undefined;
  payRollId?: string | undefined;
  payRollMonth?: string | undefined;
  loanPaymentScheduleId?: string | undefined;
  transactionDate?: string;

  constructor(data?: ITransactionEmployeeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.type = _data["type"];
      this.amount = _data["amount"];
      this.description = _data["description"];
      this.descriptionFr = _data["descriptionFr"];
      this.reference = _data["reference"];
      this.payRollId = _data["payRollId"];
      this.payRollMonth = _data["payRollMonth"];
      this.loanPaymentScheduleId = _data["loanPaymentScheduleId"];
      this.transactionDate = _data["transactionDate"];
    }
  }

  static fromJS(data: any): TransactionEmployeeDto {
    data = typeof data === 'object' ? data : {};
    let result = new TransactionEmployeeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["type"] = this.type;
    data["amount"] = this.amount;
    data["description"] = this.description;
    data["descriptionFr"] = this.descriptionFr;
    data["reference"] = this.reference;
    data["payRollId"] = this.payRollId;
    data["payRollMonth"] = this.payRollMonth;
    data["loanPaymentScheduleId"] = this.loanPaymentScheduleId;
    data["transactionDate"] = this.transactionDate;
    return data;
  }
}

export interface ITransactionEmployeeDto {
  id?: string | undefined;
  type?: TransactionType;
  amount?: number;
  description?: string | undefined;
  descriptionFr?: string | undefined;
  reference?: string | undefined;
  payRollId?: string | undefined;
  payRollMonth?: string | undefined;
  loanPaymentScheduleId?: string | undefined;
  transactionDate?: string;
}

export enum TransactionType {
  SalaryPayment = 1,
  LoanPayment = 2,
  LoanDeduction = 3,
  AdvanceSalary = 4,
}

export class GetTransactionsResponseModel implements IGetTransactionsResponseModel {
  data?: TransactionDto[] | undefined;
  count?: number;

  constructor(data?: IGetTransactionsResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(TransactionDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetTransactionsResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetTransactionsResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetTransactionsResponseModel {
  data?: TransactionDto[] | undefined;
  count?: number;
}

export class TransactionDto implements ITransactionDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  companyStaffId?: string | undefined;
  companyStaffName?: string | undefined;
  companyStaffEmail?: string | undefined;
  type?: TransactionType;
  typeText?: string | undefined;
  amount?: number;
  description?: string | undefined;
  descriptionFr?: string | undefined;
  reference?: string | undefined;
  payRollId?: string | undefined;
  payRollMonth?: string | undefined;
  loanPaymentScheduleId?: string | undefined;
  transactionDate?: string;

  constructor(data?: ITransactionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyId = _data["companyId"];
      this.companyName = _data["companyName"];
      this.companyStaffId = _data["companyStaffId"];
      this.companyStaffName = _data["companyStaffName"];
      this.companyStaffEmail = _data["companyStaffEmail"];
      this.type = _data["type"];
      this.typeText = _data["typeText"];
      this.amount = _data["amount"];
      this.description = _data["description"];
      this.descriptionFr = _data["descriptionFr"];
      this.reference = _data["reference"];
      this.payRollId = _data["payRollId"];
      this.payRollMonth = _data["payRollMonth"];
      this.loanPaymentScheduleId = _data["loanPaymentScheduleId"];
      this.transactionDate = _data["transactionDate"];
    }
  }

  static fromJS(data: any): TransactionDto {
    data = typeof data === 'object' ? data : {};
    let result = new TransactionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["companyId"] = this.companyId;
    data["companyName"] = this.companyName;
    data["companyStaffId"] = this.companyStaffId;
    data["companyStaffName"] = this.companyStaffName;
    data["companyStaffEmail"] = this.companyStaffEmail;
    data["type"] = this.type;
    data["typeText"] = this.typeText;
    data["amount"] = this.amount;
    data["description"] = this.description;
    data["descriptionFr"] = this.descriptionFr;
    data["reference"] = this.reference;
    data["payRollId"] = this.payRollId;
    data["payRollMonth"] = this.payRollMonth;
    data["loanPaymentScheduleId"] = this.loanPaymentScheduleId;
    data["transactionDate"] = this.transactionDate;
    return data;
  }
}

export interface ITransactionDto {
  id?: string | undefined;
  companyId?: string | undefined;
  companyName?: string | undefined;
  companyStaffId?: string | undefined;
  companyStaffName?: string | undefined;
  companyStaffEmail?: string | undefined;
  type?: TransactionType;
  typeText?: string | undefined;
  amount?: number;
  description?: string | undefined;
  descriptionFr?: string | undefined;
  reference?: string | undefined;
  payRollId?: string | undefined;
  payRollMonth?: string | undefined;
  loanPaymentScheduleId?: string | undefined;
  transactionDate?: string;
}

export class GetTransactionByIdResponseModel implements IGetTransactionByIdResponseModel {
  data?: TransactionDto | undefined;

  constructor(data?: IGetTransactionByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? TransactionDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetTransactionByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetTransactionByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetTransactionByIdResponseModel {
  data?: TransactionDto | undefined;
}

export class GetUsersResponseModel implements IGetUsersResponseModel {
  data?: UserDto[] | undefined;
  count?: number;

  constructor(data?: IGetUsersResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(UserDto.fromJS(item));
      }
      this.count = _data["count"];
    }
  }

  static fromJS(data: any): GetUsersResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetUsersResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    data["count"] = this.count;
    return data;
  }
}

export interface IGetUsersResponseModel {
  data?: UserDto[] | undefined;
  count?: number;
}

export class UserDto implements IUserDto {
  fullName?: string | undefined;
  id?: string | undefined;
  email?: string | undefined;
  image?: string | undefined;
  role?: string | undefined;
  createdDate?: string;
  isEnabled?: boolean;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;

  constructor(data?: IUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data["fullName"];
      this.id = _data["id"];
      this.email = _data["email"];
      this.image = _data["image"];
      this.role = _data["role"];
      this.createdDate = _data["createdDate"];
      this.isEnabled = _data["isEnabled"];
      this.isAllowEmail = _data["isAllowEmail"];
      this.isAllowNotification = _data["isAllowNotification"];
    }
  }

  static fromJS(data: any): UserDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["fullName"] = this.fullName;
    data["id"] = this.id;
    data["email"] = this.email;
    data["image"] = this.image;
    data["role"] = this.role;
    data["createdDate"] = this.createdDate;
    data["isEnabled"] = this.isEnabled;
    data["isAllowEmail"] = this.isAllowEmail;
    data["isAllowNotification"] = this.isAllowNotification;
    return data;
  }
}

export interface IUserDto {
  fullName?: string | undefined;
  id?: string | undefined;
  email?: string | undefined;
  image?: string | undefined;
  role?: string | undefined;
  createdDate?: string;
  isEnabled?: boolean;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;
}

export class ChangePasswordResponseModel implements IChangePasswordResponseModel {

  constructor(data?: IChangePasswordResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): ChangePasswordResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePasswordResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IChangePasswordResponseModel {
}

export class ChangePasswordRequestModel implements IChangePasswordRequestModel {
  currentPassword?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: IChangePasswordRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPassword = _data["currentPassword"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
    }
  }

  static fromJS(data: any): ChangePasswordRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePasswordRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currentPassword"] = this.currentPassword;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    return data;
  }
}

export interface IChangePasswordRequestModel {
  currentPassword?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
}

export class UpdatePasswordByIdResponseModel implements IUpdatePasswordByIdResponseModel {

  constructor(data?: IUpdatePasswordByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): UpdatePasswordByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePasswordByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IUpdatePasswordByIdResponseModel {
}

export class UpdatePasswordByIdRequestModel implements IUpdatePasswordByIdRequestModel {
  id?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: IUpdatePasswordByIdRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
    }
  }

  static fromJS(data: any): UpdatePasswordByIdRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePasswordByIdRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    return data;
  }
}

export interface IUpdatePasswordByIdRequestModel {
  id?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
}

export class GetUserProfileResponseModel implements IGetUserProfileResponseModel {
  data?: UserDto | undefined;

  constructor(data?: IGetUserProfileResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetUserProfileResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetUserProfileResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetUserProfileResponseModel {
  data?: UserDto | undefined;
}

export class GetUsersDropDownResponseModel implements IGetUsersDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;

  constructor(data?: IGetUsersDropDownResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(DropDownDtoOfString.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetUsersDropDownResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetUsersDropDownResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IGetUsersDropDownResponseModel {
  data?: DropDownDtoOfString[] | undefined;
}

export class GetUserByIdResponseModel implements IGetUserByIdResponseModel {
  data?: UserDetailDto | undefined;

  constructor(data?: IGetUserByIdResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? UserDetailDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): GetUserByIdResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GetUserByIdResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IGetUserByIdResponseModel {
  data?: UserDetailDto | undefined;
}

export class UserDetailDto extends UserDto implements IUserDetailDto {

  constructor(data?: IUserDetailDto) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): UserDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserDetailDto();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IUserDetailDto extends IUserDto {
}

export class CreateUserResponseModel implements ICreateUserResponseModel {
  data?: UserDto | undefined;

  constructor(data?: ICreateUserResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateUserResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateUserResponseModel {
  data?: UserDto | undefined;
}

export class CreateUserRequestModel implements ICreateUserRequestModel {
  image?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  role?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isEnabled?: boolean;

  constructor(data?: ICreateUserRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.image = _data["image"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.role = _data["role"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.isEnabled = _data["isEnabled"];
    }
  }

  static fromJS(data: any): CreateUserRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["image"] = this.image;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["role"] = this.role;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["isEnabled"] = this.isEnabled;
    return data;
  }
}

export interface ICreateUserRequestModel {
  image?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  role?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isEnabled?: boolean;
}

export class CreateUserBulkResponseModel implements ICreateUserBulkResponseModel {
  data?: UserDto[] | undefined;

  constructor(data?: ICreateUserBulkResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(UserDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CreateUserBulkResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserBulkResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface ICreateUserBulkResponseModel {
  data?: UserDto[] | undefined;
}

export class CreateUserBulkRequestModel implements ICreateUserBulkRequestModel {
  host?: string | undefined;
  users?: CreateUserBulkDto[] | undefined;

  constructor(data?: ICreateUserBulkRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.host = _data["host"];
      if (Array.isArray(_data["users"])) {
        this.users = [] as any;
        for (let item of _data["users"])
          this.users!.push(CreateUserBulkDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CreateUserBulkRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserBulkRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["host"] = this.host;
    if (Array.isArray(this.users)) {
      data["users"] = [];
      for (let item of this.users)
        data["users"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface ICreateUserBulkRequestModel {
  host?: string | undefined;
  users?: CreateUserBulkDto[] | undefined;
}

export class CreateUserBulkDto implements ICreateUserBulkDto {
  fullName?: string | undefined;
  email?: string | undefined;

  constructor(data?: ICreateUserBulkDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data["fullName"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): CreateUserBulkDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserBulkDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    return data;
  }
}

export interface ICreateUserBulkDto {
  fullName?: string | undefined;
  email?: string | undefined;
}

export class ImportUserBulkResponseModel implements IImportUserBulkResponseModel {
  data?: UserDto[] | undefined;

  constructor(data?: IImportUserBulkResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(UserDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ImportUserBulkResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new ImportUserBulkResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data)
        data["data"].push(item ? item.toJSON() : undefined as any);
    }
    return data;
  }
}

export interface IImportUserBulkResponseModel {
  data?: UserDto[] | undefined;
}

export class CreateUserWithLinkResponseModel implements ICreateUserWithLinkResponseModel {
  data?: UserDto | undefined;

  constructor(data?: ICreateUserWithLinkResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): CreateUserWithLinkResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserWithLinkResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface ICreateUserWithLinkResponseModel {
  data?: UserDto | undefined;
}

export class CreateUserWithLinkRequestModel implements ICreateUserWithLinkRequestModel {
  host?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;

  constructor(data?: ICreateUserWithLinkRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.host = _data["host"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): CreateUserWithLinkRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserWithLinkRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["host"] = this.host;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    return data;
  }
}

export interface ICreateUserWithLinkRequestModel {
  host?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
}

export class UpdateUserProfileResponseModel implements IUpdateUserProfileResponseModel {
  fullName?: string | undefined;
  image?: string | undefined;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;

  constructor(data?: IUpdateUserProfileResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data["fullName"];
      this.image = _data["image"];
      this.isAllowEmail = _data["isAllowEmail"];
      this.isAllowNotification = _data["isAllowNotification"];
    }
  }

  static fromJS(data: any): UpdateUserProfileResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserProfileResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["fullName"] = this.fullName;
    data["image"] = this.image;
    data["isAllowEmail"] = this.isAllowEmail;
    data["isAllowNotification"] = this.isAllowNotification;
    return data;
  }
}

export interface IUpdateUserProfileResponseModel {
  fullName?: string | undefined;
  image?: string | undefined;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;
}

export class UpdateUserProfileRequestModel implements IUpdateUserProfileRequestModel {
  fullName?: string | undefined;
  image?: string | undefined;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;

  constructor(data?: IUpdateUserProfileRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data["fullName"];
      this.image = _data["image"];
      this.isAllowEmail = _data["isAllowEmail"];
      this.isAllowNotification = _data["isAllowNotification"];
    }
  }

  static fromJS(data: any): UpdateUserProfileRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserProfileRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["fullName"] = this.fullName;
    data["image"] = this.image;
    data["isAllowEmail"] = this.isAllowEmail;
    data["isAllowNotification"] = this.isAllowNotification;
    return data;
  }
}

export interface IUpdateUserProfileRequestModel {
  fullName?: string | undefined;
  image?: string | undefined;
  isAllowEmail?: boolean;
  isAllowNotification?: boolean;
}

export class UpdateUserResponseModel implements IUpdateUserResponseModel {
  data?: UserDto | undefined;

  constructor(data?: IUpdateUserResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : undefined as any;
    }
  }

  static fromJS(data: any): UpdateUserResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : undefined as any;
    return data;
  }
}

export interface IUpdateUserResponseModel {
  data?: UserDto | undefined;
}

export class UpdateUserRequestModel implements IUpdateUserRequestModel {
  image?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  isEnabled?: boolean;
  id?: string | undefined;

  constructor(data?: IUpdateUserRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.image = _data["image"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.isEnabled = _data["isEnabled"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateUserRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["image"] = this.image;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["isEnabled"] = this.isEnabled;
    data["id"] = this.id;
    return data;
  }
}

export interface IUpdateUserRequestModel {
  image?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  isEnabled?: boolean;
  id?: string | undefined;
}

export class DeleteUserResponseModel implements IDeleteUserResponseModel {

  constructor(data?: IDeleteUserResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): DeleteUserResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteUserResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IDeleteUserResponseModel {
}

export class ResetPasswordResponseModel implements IResetPasswordResponseModel {

  constructor(data?: IResetPasswordResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): ResetPasswordResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new ResetPasswordResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IResetPasswordResponseModel {
}

export class ResetPasswordRequestModel implements IResetPasswordRequestModel {
  password?: string | undefined;
  confirmPassword?: string | undefined;
  token?: string | undefined;
  email?: string | undefined;

  constructor(data?: IResetPasswordRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.token = _data["token"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): ResetPasswordRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new ResetPasswordRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["token"] = this.token;
    data["email"] = this.email;
    return data;
  }
}

export interface IResetPasswordRequestModel {
  password?: string | undefined;
  confirmPassword?: string | undefined;
  token?: string | undefined;
  email?: string | undefined;
}

export class GenerateResetPasswordTokenResponseModel implements IGenerateResetPasswordTokenResponseModel {
  url?: string | undefined;

  constructor(data?: IGenerateResetPasswordTokenResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.url = _data["url"];
    }
  }

  static fromJS(data: any): GenerateResetPasswordTokenResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new GenerateResetPasswordTokenResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["url"] = this.url;
    return data;
  }
}

export interface IGenerateResetPasswordTokenResponseModel {
  url?: string | undefined;
}

export class GenerateResetPasswordTokenRequestModel implements IGenerateResetPasswordTokenRequestModel {
  host?: string | undefined;
  email?: string | undefined;

  constructor(data?: IGenerateResetPasswordTokenRequestModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.host = _data["host"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): GenerateResetPasswordTokenRequestModel {
    data = typeof data === 'object' ? data : {};
    let result = new GenerateResetPasswordTokenRequestModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["host"] = this.host;
    data["email"] = this.email;
    return data;
  }
}

export interface IGenerateResetPasswordTokenRequestModel {
  host?: string | undefined;
  email?: string | undefined;
}

export class IsUserActiveResponseModel implements IIsUserActiveResponseModel {
  isActive?: boolean;

  constructor(data?: IIsUserActiveResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): IsUserActiveResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new IsUserActiveResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["isActive"] = this.isActive;
    return data;
  }
}

export interface IIsUserActiveResponseModel {
  isActive?: boolean;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
